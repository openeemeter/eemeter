{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EEmeter","text":"<p> OpenEEmeter library, standardized framework for high performance energy prediction models. </p> <p></p> <p> </p> <p>Source Code: https://github.com/openeemeter/eemeter</p> <p>EEmeter is an open source python library for creating standardized models for predicting energy usage. These standardized models are often used to calculate energy savings post demand side intervention (such as energy efficiency projects or demand response events). </p> <p>Key Features of EEmeter include:</p> <ul> <li>Fast: EEmeter models are extremely high performance, with model builds taking milliseconds. </li> <li>Open Source: All code is open source, making EEmeter an excellent choice for measuring energy savings when results must be transparent and reproducible.</li> <li>Multiple Model Types: EEmeter offers both daily and hourly models, depending on the interval granularity available. The daily model is also compatible with billing data.</li> <li>Easy and Intuitive: The API interface is inspired by scikit-learn, a well-known data science package for building models. Just fit and predict.</li> <li>Input Data Formatting: Meter usage and temperature data is first routed through interval data classes to ensure standardization and avoid common pitfalls.</li> <li>Data Sufficiency and Model Fit Checking: Data sufficiency and model fit thresholds are built into the model, notifying users if limits are exceeded.</li> <li>Model Serialization and Deserialization: Models can be serialized into dictionaries or json objects and deserialized later.</li> <li>Pandas DataFrame Support: Input data and predictions use pandas DataFrames, a well-known format for data scientists and engineers.</li> </ul>"},{"location":"learn/","title":"General Concepts","text":"<p>In this section we will cover general concepts in regards to predicting energy usage and calculating energy savings. Other sections will contain model overviews and examples of using the library to create models and predict energy usage.</p>"},{"location":"learn/#why-predict-energy-usage","title":"Why Predict Energy Usage?","text":"<p>If you are new to the energy industry, you may be asking yourself what the use cases for predicting energy usage are. In truth, there are many use cases for predicting energy usage, and the ability to do so accurately has far-reaching consequences from the economics of a single household to the stability of the entire grid.</p> <p>Common Use Cases Include:</p> <ul> <li>Forecasting load using weather forecasts to ensure adequate energy supply for the days, weeks, months, and years ahead.</li> <li>Determining the impact of interventions such as energy efficiency and demand response. This includes:<ul> <li>Understanding the financial impact of installed interventions to accurately track ROI.</li> <li>Utilities measuring the impact of these interventions on the utility grid and effectively utilizing them as grid resources.</li> </ul> </li> <li>Implementing \"continuous commissioning\" at buildings to track changes in energy usage and diagnose equipment issues.</li> <li>And many more...</li> </ul> <p>In this documentation we'll be focused on determining energy savings. After exploring this use case, you will have all the tools needed to apply EEmeter for any use case desired.</p>"},{"location":"learn/#quantifying-energy-savings","title":"Quantifying Energy Savings","text":"<p>Within the realm of energy efficiency, there are many different ways to calculate energy savings. The fundamental problem in calculating energy savings is the production of a \"counterfactual\". What would the energy usage have been in the absence of a specific intervention such as a new HVAC system? This is impossible to truly know, but several techniques are commonly used to accomplish this.</p>"},{"location":"learn/#deemed-savings-engineering-estimates","title":"Deemed Savings / Engineering Estimates","text":"<p>This method involves contrasting the current condition of the building with the future condition of the building. This may mean comparing an existing refrigeration system with a newly installed one that is twice as efficient, or perhaps estimating the impact of behavioral changes at a site that is adapting new working procedures.</p> <p>The fundamental problem with this method is that it involves many assumptions. For example, what if the house that just installed the ultra-efficient refrigerator moves their old one into the garage? What if workers do not adapt the new working procedures as expected? Engineers and analysts can attempt to increase the accuracy of their calculations by spending more time tuning calculations to a specific site, but this increases overhead and takes time without any guarantee of increasing accuracy.</p>"},{"location":"learn/#contrasting-current-usage-with-prior-usage","title":"Contrasting Current Usage with Prior Usage","text":"<p>This method involves simply comparing the current year's usage vs. the previous year. Although this is quickly done and leverages real meter data, it disregards the difference in conditions between the two years - in particular, temperature - which can have a huge impact on the energy usage at a site.</p>"},{"location":"learn/#randomized-control-trial","title":"Randomized Control Trial","text":"<p>This method involves finding \"nearly identical\" sites that are not receiving interventions and comparing the energy usage to those receiving interventions. This side steps the temporal issue of different conditions in each year, but also introduces new challenges with finding \"nearly identical\" building to match with those receiving interventions. This can be difficult since no building is truly identical with its energy usage, but this can be compensated for with higher sample sizes and is best for residential programs.</p>"},{"location":"learn/#estimate-usage-with-a-model","title":"Estimate Usage with a Model","text":"<p>This method involves using a model to predict energy usage and then comparing it to the actual usage to determine savings. With EEmeter, this approach relies entirely on temperature and meter data to create a model that can be used to predict energy usage. </p> <p>The pros of this method include:</p> <ul> <li>No need for ad-hoc assumptions - only actual meter data and temperature impact the model.</li> <li>Temperature data is used to accurately predict energy usage and contrast energy usage between different time periods.</li> <li>No need for finding \"nearly identical\" buildings.</li> <li>Method is suitable for most buildings.</li> </ul> <p>In addition, when using EEmeter with default configuration, users can be assured of consistent methods to determine energy savings. This is a fundamentally important point when calculating energy savings - consistency. If five different people come up with five different answers, which one do you trust? If estimates are coming from parties that stand to benefit from higher savings estimates (such as energy service companies, engineers, contractors, etc), these numbers are even harder to trust. By using standardized methods, the savings calculations are deterministic and avoid dangerous assumptions.</p>"},{"location":"learn/#intervention-lifecycle","title":"Intervention Lifecycle","text":"<p>When calculating savings from an intervention, it is important to define temporal periods as these impact how we train and use our model. For a typical efficiency intervention, we will define three periods:</p> <ul> <li>Baseline Period: The period leading up to the intervention period that the model is trained on. For efficiency projects, this is 365 days. For demand response, the period may be shorter.</li> <li>Blackout Period: The period in which the intervention is being installed that should not be included in either baseline or reporting periods. During this period, energy usage is often erratic due to the installation process. For some interventions, the blackout period may be months, and for others there may be no blackout period (i.e. demand response).</li> <li>Reporting Period: The post-blackout period in which we can compare the model counterfactual to the observed energy usage to calculate savings. Reporting periods for efficiency projects typically last at least 365 days but may go far beyond this. For demand response, the reporting period is typically just the event day.</li> </ul>"},{"location":"learn/daily_billing_model/","title":"Daily / Billing Model","text":""},{"location":"learn/daily_billing_model/#model-overview","title":"Model Overview","text":"<p>The daily model is trained using daily energy usage intervals and also predicts energy usage in daily intervals. The billing model is identical to the daily model, but allows users to train using billing interval data instead, while handling the daily usage distribution under the hood.</p>"},{"location":"learn/daily_billing_model/#how-the-model-works","title":"How the Model Works","text":""},{"location":"learn/daily_billing_model/#model-shape-and-balance-points","title":"Model Shape and Balance Points","text":"<p>The daily model, at its core, utilizes a piecewise linear regression model that predicts energy usage relative to temperature. The model determines temperature balance points at which energy usage starts changing relative to temperature.</p> <p>The key terms to understand here are:</p> <ul> <li>Balance Points: Outdoor temperature thresholds beyond which heating and cooling effects are observed.</li> <li>Heating and Cooling Coefficients: Rate of increase of energy use per change in temperature beyond the balance points.</li> <li>Temperature Independent Load: The regression intercept (height of the flat line in the diagram).</li> </ul> <p>Based on the site behavior, there are four different model types that may be generated: - Heating and Cooling Loads - Heating Only Load - Cooling Only Load - Temperature Independent Load</p> <p>When the model is fit, each site will receive its own unique model fit and coefficients. The general model fitting process is as follows:</p> <ol> <li>Balance points are estimated with a global optimization algorithm.</li> <li>Sum of Squares Error (SSE) is minimized with Lasso regression inspired penalization.</li> <li>The best model type is determined (ex. cooling load only model)</li> <li>The model best fit is found using SSE.</li> </ol>"},{"location":"learn/daily_billing_model/#model-splits","title":"Model Splits","text":"<p>The process described above is effective but may have shortcomings in real life data if energy usage changes fundamentally during different time periods.</p> <p>For example, what if a site is more populated during a particular season (for example, a Summer House or Ski Lodge) or during weekdays (for example, offices and most homes). This may result in models that fail to accurately predict energy usage because they are trying to account for all time periods at once.</p> <p>To combat this, the model will create \"splits\" that will store independent models for different seasons or weekday/weekend combinations, but only if necessary. </p> <p>The general process is as follows:</p> <ol> <li>Create models using all possible splits of season/weekday|weekend.</li> <li>Calculate modified BIC (Bayesian Information Criterion) for each preliminary combination.</li> <li>Select combination with the smallest BICmod.</li> <li>Best model type is inferred and best fit is found.</li> </ol> <p>This provides a standardized process for splitting the model to better predict energy usage by certain time periods (if the benefit outweighs the additional model complexity).</p>"},{"location":"learn/daily_billing_model/#using-the-daily-model","title":"Using the Daily Model","text":""},{"location":"learn/daily_billing_model/#imports","title":"Imports","text":"<p>In this section, we'll walk through an example of creating a Daily Model and predicting usage with it.</p> <p>If you'd like to follow along, be sure to begin with the following imports. Numpy is used for one example of a disqualified meter, and matplotlib is used for plotting the data. Neither are required imports if you're not following along with the example precisely.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport eemeter\n</code></pre>"},{"location":"learn/daily_billing_model/#loading-example-data","title":"Loading Example Data","text":"<p>With our imports set, we can begin by loading some example data. Here we use a built in utility function to load some prepared test data.</p> <p>This function returns two dataframes of daily electricity data, one for the baseline period and one for the reporting period.</p> <pre><code>df_baseline, df_reporting =  eemeter.load_test_data(\"daily_treatment_data\")\n</code></pre> <p>If we inspect these dataframes, we will notice that there are 100 meters for you to experiment with, indexed by meter id and datetime.</p> <pre><code>print(df_baseline)\n</code></pre> Returns <pre><code>id      datetime                    temperature observed\n108618  2018-01-01 00:00:00-06:00   -2.384038   16635.193673\n        2018-01-02 00:00:00-06:00   1.730000    15594.051162\n        2018-01-03 00:00:00-06:00   13.087946   11928.025899\n        2018-01-04 00:00:00-06:00   4.743269    14399.333812\n        2018-01-05 00:00:00-06:00   4.130577    14315.101721\n... ... ... ...\n120841  2018-12-27 00:00:00-06:00   52.010625   1153.749811\n        2018-12-28 00:00:00-06:00   35.270000   1704.076968\n        2018-12-29 00:00:00-06:00   29.630000   2151.225729\n        2018-12-30 00:00:00-06:00   34.250000   1331.123954\n        2018-12-31 00:00:00-06:00   43.311250   1723.397349\n</code></pre> <p>To simplify things, we will filter down to a single meter for the rest of the example. Let's filter down to id 108618.</p> <pre><code>df_baseline_108618 = df_baseline.loc[108618]\ndf_reporting_108618 = df_reporting.loc[108618]\n</code></pre> <p>If we inspect one of these dataframes, we will now notice that only a single meter is present with 365 days of data in each dataframe. </p> <pre><code>print(df_baseline_108618)\n</code></pre> Returns <pre><code>datetime                    temperature observed\n2018-01-01 00:00:00-06:00   -2.384038   16635.193673\n2018-01-02 00:00:00-06:00   1.730000    15594.051162\n2018-01-03 00:00:00-06:00   13.087946   11928.025899\n2018-01-04 00:00:00-06:00   4.743269    14399.333812\n2018-01-05 00:00:00-06:00   4.130577    14315.101721\n... ... ...\n2018-12-27 00:00:00-06:00   46.602066   4528.347029\n2018-12-28 00:00:00-06:00   38.346724   5647.646228\n2018-12-29 00:00:00-06:00   28.614456   5338.377496\n2018-12-30 00:00:00-06:00   29.186923   6280.238343\n2018-12-31 00:00:00-06:00   36.510441   4966.566443\n</code></pre> <p>Also notice the general structure of these dataframes for a single meter. We have three columns: 1. A timezone-aware datetime index. 2. A temperature column (float) in Fahrenheit (be sure to convert any other units to Fahrenheit first). 3. Observed meter usage (float). Our example is electricity data in kWh, but it could also be gas data.</p> <p>We can stop to plot this data to get a better understanding of the general behavior of this meter. <pre><code>ax = df_baseline_108618['observed'].plot(label='Observed Usage', color='blue')\ndf_baseline_108618['temperature'].plot(ax=ax, secondary_y=True, label='Temperature (F)', color='orange')\n\nax.set_ylabel('Observed Usage (kWh)')\nax.right_ax.set_ylabel('Temperature (F)')\n\nax.legend(loc='upper left')\nax.right_ax.legend(loc='upper right')\n\nplt.title('Observed Usage and Temperature in the Baseline Period')\nplt.show()\n</code></pre></p> Returns <p> </p> <p>If we observe the data we can see a full year of data with observed usage peaking in the winter and lowering in the summer with warmer temperatures. It's clear that this site is located in a colder climate and uses more electricity in the winter.</p>"},{"location":"learn/daily_billing_model/#loading-data-into-eemeter-data-objects","title":"Loading Data into EEmeter Data Objects","text":"<p>With our sample data loaded into dataframes, we can create our Baseline and Reporting Data objects. Note that only the baseline period is needed to fit a model, but we will use our reporting period data to predict against.</p> <pre><code>baseline_data = eemeter.eemeter.DailyBaselineData(df_baseline_108618, is_electricity_data=True)\nreporting_data = eemeter.eemeter.DailyReportingData(df_reporting_108618, is_electricity_data=True)\n</code></pre> <p>These classes are critical to ensure standardized data loaded into the model, and they also scan the data to check for data sufficiency and other criteria that might cause a model to be disqualified (unable to build a model of sufficient integrity).</p> <p>As a note, you can also instantiate these data classes with two separate meter usage and temperature Series objects, both indexed by timezone-aware datetime.</p> Example <pre><code>baseline_data = eemeter.eemeter.DailyBaselineData.from_series(df_baseline_108618['observed'], df_baseline_108618['temperature'], is_electricity_data=True)\n</code></pre> <p>With data classes successfully instantiated, we can also check for any disqualifications or warnings before moving on to the model fitting step.</p> <pre><code>print(f\"Disqualifications: {baseline_data.disqualification}\")\nprint(f\"Warnings:          {baseline_data.warnings}\")\n</code></pre> Returns <pre><code>Disqualifications: []\nWarnings:          [EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.unable_to_confirm_daily_temperature_sufficiency), \n                    EEMeterWarning(qualified_name=eemeter.sufficiency_criteria.extreme_values_detected)]\n</code></pre> <p>From this, we can see that no disqualifications are present but there are some warnings to be aware of as we proceed. Neither of these warnings will necessarily stop us from creating a model.</p> <p>Before we move on, also notice that you can access the underlying dataframe in each object like follows to see exactly what will be loaded into the model.</p> <pre><code>print(baseline_data.df.head())\n</code></pre> Returns <pre><code>datetime                    season  weekday_weekend temperature observed\n2018-01-01 00:00:00-06:00   winter  weekday         -2.384038   16635.193673\n2018-01-02 00:00:00-06:00   winter  weekday         1.730000    15594.051162\n2018-01-03 00:00:00-06:00   winter  weekday         13.087946   11928.025899\n2018-01-04 00:00:00-06:00   winter  weekday         4.743269    14399.333812\n2018-01-05 00:00:00-06:00   winter  weekday         4.130577    14315.101721\n</code></pre>"},{"location":"learn/daily_billing_model/#creating-the-model","title":"Creating the Model","text":"<p>The daily model follows the general process of: 1. Initialize 2. Fit 3. Predict</p> <p>We can do this easily as follows:</p> <pre><code>daily_model = eemeter.eemeter.DailyModel()\ndaily_model.fit(baseline_data)\n</code></pre> <p>Before we move to predicting against a dataframe, we can actually use the built in plot function (requiring matplotlib) to plot the performance of the model against the provided data.</p> <pre><code>daily_model.plot(baseline_data)\n</code></pre> Returns <p> </p> <p>From this graph we can also observe model splits and model types as described in the Model Splits section. We can observe the following models:</p> <ol> <li>Shoulder/Winter - Weekday</li> <li>Summer - Weekday</li> <li>Summer/Shoulder/Winter - Weekend</li> </ol> <p>This illustrates that Summer/Shoulder/Winter weekends were similar enough to be modeled together, but Summer weekdays and Shoulder/Winter weekdays were different enough to require separate models. All of this complexity is handled under the hood, and the model will utilize the correct model when predicting usage automatically.</p> <p>We can also use this function to plot the model prediction against the reporting period as follows:</p> <pre><code>daily_model.plot(reporting_data)\n</code></pre> Returns <p> </p> <p>In this plot we can see that the site is using significantly less energy in colder temperatures compared to the model / baseline period. Perhaps this site installed an efficiency intervention that saves energy in colder temperatures?</p>"},{"location":"learn/daily_billing_model/#predicting-with-the-model-and-calculating-savings","title":"Predicting with the Model and Calculating Savings","text":"<p>With our fit model, we can now predict across a given reporting period as follows:</p> <pre><code>df_results = daily_model.predict(reporting_data)\nprint(df_results.head())\n</code></pre> Returns <pre><code>datetime                    season  day_of_week weekday_weekend temperature observed    predicted       predicted_unc   heating_load    cooling_load    model_split model_type                                          \n2019-01-01 00:00:00-06:00   winter  2           weekday         -2.384038   9294.220619 15610.330791    1181.674285     14344.873494    0.0             wd-sh_wi    hdd_tidd_cdd_smooth\n2019-01-02 00:00:00-06:00   winter  3           weekday         1.730000    8073.766329 14464.613486    1181.674285     13199.156189    0.0             wd-sh_wi    hdd_tidd_cdd_smooth\n2019-01-03 00:00:00-06:00   winter  4           weekday         13.087946   5261.174665 11322.966704    1181.674285     10057.509407    0.0             wd-sh_wi    hdd_tidd_cdd_smooth\n2019-01-04 00:00:00-06:00   winter  5           weekday         4.743269    6775.499525 13627.487003    1181.674285     12362.029706    0.0             wd-sh_wi    hdd_tidd_cdd_smooth\n2019-01-05 00:00:00-06:00   winter  6           weekend         4.130577    6735.513000 11690.139993    1224.574703     11200.780385    0.0             we-su_sh_wi hdd_tidd_cdd_smooth\n</code></pre> <p>We can also plot the observed usage vs. the predicted usage.</p> <pre><code>ax = df_results['observed'].plot(label='Observed Usage', color='blue')\ndf_results['predicted'].plot(ax=ax, label='Predicted Usage', color='orange')\n\nax.set_ylabel('Observed Usage (kWh)')\nax.legend(loc='upper left')\nplt.title('Observed Usage and Temperature in the Baseline Period')\nplt.savefig('predicted_vs_observed_daily.png')\nplt.show()\n</code></pre> Returns <p> </p> <p>From here, we can easily calculate savings by subtracting observed usage from predicted usage.</p> <pre><code>df_results['savings'] = df_results['predicted'] - df_results['observed']\nprint(f\"Predicted Usage (kWh):  {round(df_results['predicted'].sum(), 2)}\")\nprint(f\"Observed Usage (kWh):   {round(df_results['observed'].sum(), 2)}\")\nprint(f\"Savings (kWh):          {round(df_results['savings'].sum(), 2)}\")\n</code></pre> Returns <pre><code>Predicted Usage (kWh):  1297651.07\nObserved Usage (kWh):   632077.62\nSavings (kWh):          665573.45\n</code></pre>"},{"location":"learn/daily_billing_model/#model-serialization","title":"Model Serialization","text":"<p>After creating a model, we can also serialize it for storage and read it back in later.</p> <pre><code>saved_model = daily_model.to_json()\nprint(saved_model)\n</code></pre> Returns <pre><code>{\n\"submodels\": {\n    \"wd-su\": {\n    \"coefficients\": {\n        \"model_type\": \"tidd_cdd_smooth\",\n        \"intercept\": 1036.62605016263,\n        \"hdd_bp\": null,\n        \"hdd_beta\": null,\n        \"hdd_k\": null,\n        \"cdd_bp\": 63.112946428571426,\n        \"cdd_beta\": 55.8938901507189,\n        \"cdd_k\": 7.610345707770536\n    },\n    \"temperature_constraints\": {\n        \"T_min\": 56.096346153846156,\n        \"T_max\": 85.60365384615385,\n        \"T_min_seg\": 63.112946428571426,\n        \"T_max_seg\": 81.97444606863725\n    },\n    \"f_unc\": 287.2717928729389\n    },\n    \"wd-sh_wi\": {\n    \"coefficients\": {\n        \"model_type\": \"hdd_tidd_cdd_smooth\",\n        \"intercept\": 1265.4572967952768,\n        \"hdd_bp\": 48.66708982684446,\n        \"hdd_beta\": 280.56118289086174,\n        \"hdd_k\": 0.4861025625521579,\n        \"cdd_bp\": 74.4246153846154,\n        \"cdd_beta\": 76.12622638483967,\n        \"cdd_k\": 0.2941773382321021\n    },\n    \"temperature_constraints\": {\n        \"T_min\": -2.3840384615384616,\n        \"T_max\": 79.53846153846153,\n        \"T_min_seg\": 13.432307692307694,\n        \"T_max_seg\": 74.4246153846154\n    },\n    \"f_unc\": 1181.6742853434923\n    },\n    \"we-su_sh_wi\": {\n    \"coefficients\": {\n        \"model_type\": \"hdd_tidd_cdd_smooth\",\n        \"intercept\": 489.35960795932726,\n        \"hdd_bp\": 51.43882581026119,\n        \"hdd_beta\": 236.45604355078808,\n        \"hdd_k\": 0.4856836346837153,\n        \"cdd_bp\": 74.55925252366727,\n        \"cdd_beta\": 66.31199103689823,\n        \"cdd_k\": 0.36878985440304235\n    },\n    \"temperature_constraints\": {\n        \"T_min\": 6.881923076923076,\n        \"T_max\": 87.51442307692308,\n        \"T_min_seg\": 23.602702266483515,\n        \"T_max_seg\": 81.8328021978022\n    },\n    \"f_unc\": 1224.5747026357867\n    }\n},\n\"info\": {\n    \"error\": {\n    \"wRMSE\": 580.7962073579329,\n    \"RMSE\": 580.7962073579328,\n    \"MAE\": 380.9965311661661,\n    \"CVRMSE\": 0.16332929359071596,\n    \"PNRMSE\": 0.06465498558194696\n    },\n    \"baseline_timezone\": \"America/Chicago\",\n    \"disqualification\": [],\n    \"warnings\": [\n    {\n        \"qualified_name\": \"eemeter.sufficiency_criteria.unable_to_confirm_daily_temperature_sufficiency\",\n        \"description\": \"Cannot confirm that pre-aggregated temperature data had sufficient hours kept\",\n        \"data\": {}\n    },\n    {\n        \"qualified_name\": \"eemeter.sufficiency_criteria.extreme_values_detected\",\n        \"description\": \"Extreme values (greater than (median + (3 * IQR)), must be flagged for manual review.\",\n        \"data\": {\n        \"n_extreme_values\": 2,\n        \"median\": 2527.7263175451776,\n        \"upper_quantile\": 5347.202740928209,\n        \"lower_quantile\": 1247.7751658179252,\n        \"extreme_value_limit\": 14826.00904287603,\n        \"max_value\": 16635.193672683698\n        }\n    }\n    ]\n},\n\"settings\": {\n    \"algorithm_choice\": \"nlopt_sbplx\",\n    \"allow_separate_shoulder\": true,\n    \"allow_separate_summer\": true,\n    \"allow_separate_weekday_weekend\": true,\n    \"allow_separate_winter\": true,\n    \"alpha_final\": \"adaptive\",\n    \"alpha_final_type\": \"last\",\n    \"alpha_minimum\": -100.0,\n    \"alpha_selection\": 2.0,\n    \"cvrmse_threshold\": 1.0,\n    \"developer_mode\": false,\n    \"final_bounds_scalar\": 1.0,\n    \"full_model\": \"hdd_tidd_cdd\",\n    \"initial_guess_algorithm_choice\": \"nlopt_direct\",\n    \"initial_smoothing_parameter\": 0.5,\n    \"initial_step_percentage\": 0.1,\n    \"is_weekday\": {\n    \"1\": true,\n    \"2\": true,\n    \"3\": true,\n    \"4\": true,\n    \"5\": true,\n    \"6\": false,\n    \"7\": false\n    },\n    \"maximum_slope_OoM_scaler\": 2.0,\n    \"reduce_splits_by_gaussian\": true,\n    \"reduce_splits_num_std\": [\n    1.4,\n    0.89\n    ],\n    \"regularization_alpha\": 0.001,\n    \"regularization_percent_lasso\": 1.0,\n    \"season\": {\n    \"1\": \"winter\",\n    \"2\": \"winter\",\n    \"3\": \"shoulder\",\n    \"4\": \"shoulder\",\n    \"5\": \"shoulder\",\n    \"6\": \"summer\",\n    \"7\": \"summer\",\n    \"8\": \"summer\",\n    \"9\": \"summer\",\n    \"10\": \"shoulder\",\n    \"11\": \"winter\",\n    \"12\": \"winter\"\n    },\n    \"segment_minimum_count\": 6,\n    \"smoothed_model\": true,\n    \"split_selection_criteria\": \"bic\",\n    \"split_selection_penalty_multiplier\": 0.24,\n    \"split_selection_penalty_power\": 2.061,\n    \"uncertainty_alpha\": 0.1\n}\n}\n</code></pre> <p>Afterwards, we can instantiate the model as follows:</p> <pre><code>loaded_model = eemeter.eemeter.DailyModel.from_json(saved_model)\n</code></pre>"},{"location":"learn/daily_billing_model/#billing-data-model-differences","title":"Billing Data / Model Differences","text":"<p>The Daily Model section generally applies to billing data as the same underlying model is used, but there are some key things to be aware of. It is strongly recommended to read the daily model section before this section.</p>"},{"location":"learn/daily_billing_model/#loading-example-data_1","title":"Loading Example Data","text":"<p>Like the daily model, we will start by loading some specific billing data.</p> <pre><code>df_baseline, df_reporting = eemeter.load_test_data(\"monthly_treatment_data\")\n</code></pre> <p>If we inspect these dataframes, we will notice that there are 100 meters for you to experiment with, indexed by meter id and datetime. Like before, we will filter to a single meter.</p> <pre><code>df_baseline_108618 = df_baseline.loc[108618]\ndf_reporting_108618 = df_reporting.loc[108618]\n</code></pre> <p>If we inspect one of these dataframes, we will now notice that only a single meter is present with 365 days of data in each dataframe. </p> <pre><code>print(df_baseline_108618)\n</code></pre> Returns <pre><code>id      datetime                     temperature     observed                       \n108618  2018-01-01 00:00:00-06:00    -2.384038  257406.539278\n        2018-01-02 00:00:00-06:00     1.730000            NaN\n        2018-01-03 00:00:00-06:00    13.087946            NaN\n        2018-01-04 00:00:00-06:00     4.743269            NaN\n        2018-01-05 00:00:00-06:00     4.130577            NaN\n...                                       ...            ...\n120841  2018-12-27 00:00:00-06:00    52.010625            NaN\n        2018-12-28 00:00:00-06:00    35.270000            NaN\n        2018-12-29 00:00:00-06:00    29.630000            NaN\n        2018-12-30 00:00:00-06:00    34.250000            NaN\n        2018-12-31 00:00:00-06:00    43.311250            NaN\n</code></pre> <p>However, notice that we only have one observed value per month, even though we still have daily temperature data. The observed usage in a given month will be spread evenly across all days in the month when we instantiate the data classes.</p>"},{"location":"learn/daily_billing_model/#loading-data-into-eemeter-data-objects_1","title":"Loading Data into EEmeter Data Objects","text":"<p>Like the daily model, we will instantiate data objects, but this time we will use the Billing variant.</p> <pre><code>billing_baseline_data = eemeter.eemeter.BillingBaselineData(df_baseline_108618, is_electricity_data=True)\nbilling_reporting_data = eemeter.eemeter.BillingReportingData(df_reporting_108618, is_electricity_data=True)\n</code></pre> <p>Notice that the observed usage for each day is automatically spread evenly from the monthly usage provided.</p> Returns <pre><code>datetime                    season  weekday_weekend temperature observed\n2018-01-01 00:00:00-06:00   winter  weekday         -2.384038   8303.436751\n2018-01-02 00:00:00-06:00   winter  weekday         1.730000    8303.436751\n2018-01-03 00:00:00-06:00   winter  weekday         13.087946   8303.436751\n2018-01-04 00:00:00-06:00   winter  weekday         4.743269    8303.436751\n2018-01-05 00:00:00-06:00   winter  weekday         4.130577    8303.436751\n... ... ... ... ...\n2018-12-27 00:00:00-06:00   winter  weekday         46.602066   5288.700172\n2018-12-28 00:00:00-06:00   winter  weekday         38.346724   5288.700172\n2018-12-29 00:00:00-06:00   winter  weekend         28.614456   5288.700172\n2018-12-30 00:00:00-06:00   winter  weekend         29.186923   5288.700172\n2018-12-31 00:00:00-06:00   winter  weekday         36.510441   5288.700172\n</code></pre>"},{"location":"learn/daily_billing_model/#creating-the-model-and-predicting","title":"Creating the Model and Predicting","text":"<p>With the data classes instantiated, we can now fit and predict like normal.</p> <pre><code>billing_model = eemeter.eemeter.BillingModel().fit(billing_baseline_data, ignore_disqualification=False)\nprint(billing_model.predict(billing_reporting_data).head())\n</code></pre> Returns <pre><code>datetime                    season  day_of_week weekday_weekend temperature observed    predicted   predicted_unc   heating_load    cooling_load    model_split model_type                      \n2019-01-01 00:00:00-06:00   winter  2           weekday         -2.384038   3655.09121  9733.728179 2316.237742     8530.919994     0.0             fw-su_sh_wi hdd_tidd_cdd\n2019-01-02 00:00:00-06:00   winter  3           weekday         1.730000    3655.09121  9235.507988 2316.237742     8032.699803     0.0             fw-su_sh_wi hdd_tidd_cdd\n2019-01-03 00:00:00-06:00   winter  4           weekday         13.087946   3655.09121  7860.032700 2316.237742     6657.224516     0.0             fw-su_sh_wi hdd_tidd_cdd\n2019-01-04 00:00:00-06:00   winter  5           weekday         4.743269    3655.09121  8870.593662 2316.237742     7667.785478     0.0             fw-su_sh_wi hdd_tidd_cdd\n2019-01-05 00:00:00-06:00   winter  6           weekend         4.130577    3655.09121  8944.792210 2316.237742     7741.984025     0.0             fw-su_sh_wi hdd_tidd_cdd\n</code></pre> <p>Notice that the returned data is at the daily level, showing daily predictions and observed values. We can also aggregate this data up to a higher level as follows.</p> <pre><code>print(billing_model.predict(billing_reporting_data, aggregation=\"monthly\"))\n</code></pre> Returns <pre><code>datetime                    season      temperature observed        predicted       predicted_unc   heating_load    cooling_load    model_split model_type                              \n2019-01-01 00:00:00-06:00   winter      25.612211   113307.827517   196642.717137   12896.265955    159355.663417   0.000000        fw-su_sh_wi hdd_tidd_cdd\n2019-02-01 00:00:00-06:00   winter      29.523429   81056.766022    164350.346292   12256.378085    130671.717126   0.000000        fw-su_sh_wi hdd_tidd_cdd\n2019-03-01 00:00:00-06:00   shoulder    36.122525   62783.320515    157185.144004   12896.265955    119898.090284   0.000000        fw-su_sh_wi hdd_tidd_cdd\n2019-04-01 00:00:00-05:00   shoulder    40.599556   53542.223426    135849.270725   12686.556598    99765.025189    0.000000        fw-su_sh_wi hdd_tidd_cdd\n2019-05-01 00:00:00-05:00   shoulder    64.969863   31089.429512    59427.613500    12896.265955    22047.507990    93.051790       fw-su_sh_wi hdd_tidd_cdd\n2019-06-01 00:00:00-05:00   summer      70.262968   29346.533659    43017.949048    12686.556598    6801.829282     131.874231      fw-su_sh_wi hdd_tidd_cdd\n2019-07-01 00:00:00-05:00   summer      75.915400   32743.001296    37549.881062    12896.265955    0.000000        262.827342      fw-su_sh_wi hdd_tidd_cdd\n2019-08-01 00:00:00-05:00   summer      75.706736   33660.542162    38028.046427    12896.265955    480.770213      260.222494      fw-su_sh_wi hdd_tidd_cdd\n2019-09-01 00:00:00-05:00   summer      68.480234   30381.828023    46721.644687    12686.556598    10530.068712    107.330440      fw-su_sh_wi hdd_tidd_cdd\n2019-10-01 00:00:00-05:00   shoulder    52.733661   34995.917728    97491.932913    12896.265955    60181.378730    23.500463       fw-su_sh_wi hdd_tidd_cdd\n2019-11-01 00:00:00-05:00   winter      35.239608   63200.887271    155322.359404   12686.556598    119238.113869   0.000000        fw-su_sh_wi hdd_tidd_cdd\n2019-12-01 00:00:00-06:00   winter      33.696016   65969.341170    166294.687445   12896.265955    129007.633726   0.000000        fw-su_sh_wi hdd_tidd_cdd\n</code></pre> <p>With the monthly aggregation, the resulting dataframe is aggregated by month and 12 rows are returned.</p>"},{"location":"learn/hourly_model/","title":"Hourly Model","text":"<p>The hourly model is currently receiving and update and a new tutorial is coming soon.</p>"},{"location":"reference/eemeter/billing_model/","title":"Billing Model","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing","title":"<code>eemeter.eemeter.models.billing</code>","text":"<p>A module housing billing model classes and functions.</p> <p>Copyright 2014-2024 OpenEEmeter contributors</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel","title":"<code>BillingModel(settings=None)</code>","text":"<p>A class to fit a model to the input meter data.</p> <p>BillingModel is a wrapper for the DailyModel class using billing presets.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of settings.</p> <code>seasonal_options</code> <code>list</code> <p>A list of seasonal options (su: Summer, sh: Shoulder, wi: Winter). Elements in the list are seasons separated by '_' that represent a model split. For example, a list of ['su_sh', 'wi'] represents two splits: summer/shoulder and winter.</p> <code>day_options</code> <code>list</code> <p>A list of day options.</p> <code>combo_dictionary</code> <code>dict</code> <p>A dictionary of combinations.</p> <code>df_meter</code> <code>DataFrame</code> <p>A dataframe of meter data.</p> <code>error</code> <code>dict</code> <p>A dictionary of error metrics.</p> <code>combinations</code> <code>list</code> <p>A list of combinations.</p> <code>components</code> <code>list</code> <p>A list of components.</p> <code>fit_components</code> <code>list</code> <p>A list of fit components.</p> <code>wRMSE_base</code> <code>float</code> <p>The mean bias error for no splits.</p> <code>best_combination</code> <code>list</code> <p>The best combination of splits.</p> <code>model</code> <code>Pipeline</code> <p>The final fitted model.</p> <code>id</code> <code>str</code> <p>The index of the meter data.</p> Source code in <code>eemeter/eemeter/models/billing/model.py</code> <pre><code>def __init__(self, settings=None):\n    super().__init__(model=\"legacy\", settings=settings)\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.settings","title":"<code>settings = default_settings(**settings)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.seasonal_options","title":"<code>seasonal_options = [['su_sh_wi'], ['su', 'sh_wi'], ['su_sh', 'wi'], ['su_wi', 'sh'], ['su', 'sh', 'wi']]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.day_options","title":"<code>day_options = [['wd', 'we']]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.combo_dictionary","title":"<code>combo_dictionary = {'su': 'summer', 'sh': 'shoulder', 'wi': 'winter', 'fw': [n + 1 for n in n_week], 'wd': [n + 1 for n in n_week if self.settings.is_weekday[n + 1]], 'we': [n + 1 for n in n_week if not self.settings.is_weekday[n + 1]]}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.error","title":"<code>error = {'wRMSE': np.nan, 'RMSE': np.nan, 'MAE': np.nan, 'CVRMSE': np.nan, 'PNRMSE': np.nan}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.to_json","title":"<code>to_json()</code>","text":"<p>Returns a JSON string of model parameters.</p> <p>Returns:</p> Type Description <code>str</code> <p>Model parameters.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns a JSON string of model parameters.\n\n    Returns:\n        Model parameters.\n    \"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a instance of the class from a dictionary (such as one produced from the to_dict method).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the model data.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_dict(cls, data) -&gt; DailyModel:\n    \"\"\"Create a instance of the class from a dictionary (such as one produced from the to_dict method).\n\n    Args:\n        data (dict): The dictionary containing the model data.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    settings = data.get(\"settings\")\n    daily_model = cls(settings=settings)\n    info = data.get(\"info\")\n    daily_model.params = DailyModelParameters(\n        submodels=data.get(\"submodels\"),\n        info=info,\n        settings=settings,\n    )\n\n    def deserialize_warnings(warnings):\n        if not warnings:\n            return []\n        warn_list = []\n        for warning in warnings:\n            warn_list.append(\n                EEMeterWarning(\n                    qualified_name=warning.get(\"qualified_name\"),\n                    description=warning.get(\"description\"),\n                    data=warning.get(\"data\"),\n                )\n            )\n        return warn_list\n\n    daily_model.disqualification = deserialize_warnings(\n        info.get(\"disqualification\")\n    )\n    daily_model.warnings = deserialize_warnings(info.get(\"warnings\"))\n    daily_model.baseline_timezone = info.get(\"baseline_timezone\")\n    daily_model.is_fitted = True\n    return daily_model\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.from_json","title":"<code>from_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <code>str</code> <p>The JSON string representing the object.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_json(cls, str_data: str) -&gt; DailyModel:\n    \"\"\"Create an instance of the class from a JSON string.\n\n    Args:\n        str_data: The JSON string representing the object.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    return cls.from_dict(json.loads(str_data))\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.from_2_0_dict","title":"<code>from_2_0_dict(data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a legacy (2.0) model dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing the necessary data (legacy 2.0) to create a DailyModel instance.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_2_0_dict(cls, data) -&gt; DailyModel:\n    \"\"\"Create an instance of the class from a legacy (2.0) model dictionary.\n\n    Args:\n        data (dict): A dictionary containing the necessary data (legacy 2.0) to create a DailyModel instance.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    daily_model = cls(model=\"legacy\")\n    daily_model.params = DailyModelParameters.from_2_0_params(data)\n    daily_model.warnings = []\n    daily_model.disqualification = []\n    daily_model.baseline_timezone = \"UTC\"\n    daily_model.is_fitted = True\n    return daily_model\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.from_2_0_json","title":"<code>from_2_0_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a legacy (2.0) JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <code>str</code> <p>The JSON string.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_2_0_json(cls, str_data: str) -&gt; DailyModel:\n    \"\"\"Create an instance of the class from a legacy (2.0) JSON string.\n\n    Args:\n        str_data: The JSON string.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    return cls.from_2_0_dict(json.loads(str_data))\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.fit","title":"<code>fit(baseline_data, ignore_disqualification=False)</code>","text":"<p>Fit the model using baseline data.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_data</code> <code>BillingBaselineData</code> <p>BillingBaselineData object.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore disqualification errors / warnings.</p> <code>False</code> <p>Returns:</p> Type Description <code>BillingModel</code> <p>The fitted model.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If baseline_data is not a BillingBaselineData object.</p> <code>DataSufficiencyError</code> <p>If the model can't be fit on disqualified baseline data.</p> Source code in <code>eemeter/eemeter/models/billing/model.py</code> <pre><code>def fit(\n    self, baseline_data: BillingBaselineData, ignore_disqualification: bool = False\n) -&gt; BillingModel:\n    \"\"\"Fit the model using baseline data.\n\n    Args:\n        baseline_data: BillingBaselineData object.\n        ignore_disqualification: Whether to ignore disqualification errors / warnings.\n\n    Returns:\n        The fitted model.\n\n    Raises:\n        TypeError: If baseline_data is not a BillingBaselineData object.\n        DataSufficiencyError: If the model can't be fit on disqualified baseline data.\n    \"\"\"\n    # TODO there's a fair bit of duplicated code between this and daily fit(), refactor\n    if not isinstance(baseline_data, BillingBaselineData):\n        raise TypeError(\"baseline_data must be a BillingBaselineData object\")\n    baseline_data.log_warnings()\n    if baseline_data.disqualification and not ignore_disqualification:\n        for warning in baseline_data.disqualification + baseline_data.warnings:\n            print(warning.json())\n        raise DataSufficiencyError(\"Can't fit model on disqualified baseline data\")\n    self.baseline_timezone = baseline_data.tz\n    self.warnings = baseline_data.warnings\n    self.disqualification = baseline_data.disqualification\n    self._fit(baseline_data.df)\n    if self.error[\"CVRMSE\"] &gt; self.settings.cvrmse_threshold:\n        cvrmse_warning = EEMeterWarning(\n            qualified_name=\"eemeter.model_fit_metrics.cvrmse\",\n            description=(\n                f\"Fit model has CVRMSE &gt; {self.settings.cvrmse_threshold}\"\n            ),\n            data={\"CVRMSE\": self.error[\"CVRMSE\"]},\n        )\n        cvrmse_warning.warn()\n        self.disqualification.append(cvrmse_warning)\n    return self\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.predict","title":"<code>predict(reporting_data, aggregation=None, ignore_disqualification=False)</code>","text":"<p>Predicts the energy consumption using the fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>reporting_data</code> <code>BillingBaselineData | BillingReportingData</code> <p>The data used for prediction.</p> required <code>aggregation</code> <code>str | None</code> <p>The aggregation level for the prediction. One of [None, 'none', 'monthly', 'bimonthly'].</p> <code>None</code> <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore model disqualification. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with input data along with predicted energy consumption.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the model is not fitted.</p> <code>DisqualifiedModelError</code> <p>If the model is disqualified and ignore_disqualification is False.</p> <code>TypeError</code> <p>If the reporting data is not of type BillingBaselineData or BillingReportingData.</p> <code>ValueError</code> <p>If the aggregation is not one of [None, 'none', 'monthly', 'bimonthly'].</p> Source code in <code>eemeter/eemeter/models/billing/model.py</code> <pre><code>def predict(\n    self,\n    reporting_data: BillingBaselineData | BillingReportingData,\n    aggregation: str | None = None,\n    ignore_disqualification: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Predicts the energy consumption using the fitted model.\n\n    Args:\n        reporting_data: The data used for prediction.\n        aggregation: The aggregation level for the prediction. One of [None, 'none', 'monthly', 'bimonthly'].\n        ignore_disqualification: Whether to ignore model disqualification. Defaults to False.\n\n    Returns:\n        Dataframe with input data along with predicted energy consumption.\n\n    Raises:\n        RuntimeError: If the model is not fitted.\n        DisqualifiedModelError: If the model is disqualified and ignore_disqualification is False.\n        TypeError: If the reporting data is not of type BillingBaselineData or BillingReportingData.\n        ValueError: If the aggregation is not one of [None, 'none', 'monthly', 'bimonthly'].\n    \"\"\"\n    if not self.is_fitted:\n        raise RuntimeError(\"Model must be fit before predictions can be made.\")\n\n    if self.disqualification and not ignore_disqualification:\n        raise DisqualifiedModelError(\n            \"Attempting to predict using disqualified model without setting ignore_disqualification=True\"\n        )\n\n    if not isinstance(reporting_data, (BillingBaselineData, BillingReportingData)):\n        raise TypeError(\n            \"reporting_data must be a BillingBaselineData or BillingReportingData object\"\n        )\n\n    df_res = self._predict(reporting_data.df)\n\n    if aggregation is None:\n        agg = None\n    elif aggregation.lower() == \"none\":\n        agg = None\n    elif aggregation == \"monthly\":\n        agg = \"MS\"\n    elif aggregation == \"bimonthly\":\n        agg = \"2MS\"\n    else:\n        raise ValueError(\n            \"aggregation must be one of [None, 'monthly', 'bimonthly']\"\n        )\n\n    if agg is not None:\n        sum_quad = lambda x: np.sqrt(np.sum(np.square(x)))\n\n        season = df_res[\"season\"].resample(agg).first()\n        temperature = df_res[\"temperature\"].resample(agg).mean()\n        observed = df_res[\"observed\"].resample(agg).sum()\n        predicted = df_res[\"predicted\"].resample(agg).sum()\n        predicted_unc = df_res[\"predicted_unc\"].resample(agg).apply(sum_quad)\n        heating_load = df_res[\"heating_load\"].resample(agg).sum()\n        cooling_load = df_res[\"cooling_load\"].resample(agg).sum()\n        model_split = df_res[\"model_split\"].resample(agg).first()\n        model_type = df_res[\"model_type\"].resample(agg).first()\n\n        df_res = pd.concat(\n            [\n                season,\n                temperature,\n                observed,\n                predicted,\n                predicted_unc,\n                heating_load,\n                cooling_load,\n                model_split,\n                model_type,\n            ],\n            axis=1,\n        )\n\n    return df_res\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.plot","title":"<code>plot(df_eval, aggregation=None)</code>","text":"<p>Plot a model fit with baseline or reporting data. Requires matplotlib to use.</p> <p>Parameters:</p> Name Type Description Default <code>df_eval</code> <p>The baseline or reporting data object to plot.</p> required <code>aggregation</code> <code>str | None</code> <p>The aggregation level for the prediction. One of [None, 'none', 'monthly', 'bimonthly'].</p> <code>None</code> Source code in <code>eemeter/eemeter/models/billing/model.py</code> <pre><code>def plot(\n    self,\n    df_eval,\n    aggregation: str | None = None,\n):\n    \"\"\"Plot a model fit with baseline or reporting data. Requires matplotlib to use.\n\n    Args:\n        df_eval: The baseline or reporting data object to plot.\n        aggregation: The aggregation level for the prediction. One of [None, 'none', 'monthly', 'bimonthly'].\n    \"\"\"\n    try:\n        from eemeter.eemeter.models.billing.plot import plot\n    except ImportError:  # pragma: no cover\n        raise ImportError(\"matplotlib is required for plotting.\")\n\n    # TODO: pass more kwargs to plotting function\n\n    plot(self, self.predict(df_eval, aggregation=aggregation))\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingModel.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Model parameters.</p> Source code in <code>eemeter/eemeter/models/billing/model.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns a dictionary of model parameters.\n\n    Returns:\n        Model parameters.\n    \"\"\"\n    model_dict = super().to_dict()\n    model_dict[\"settings\"][\"developer_mode\"] = True\n\n    return model_dict\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData","title":"<code>BillingBaselineData(df, is_electricity_data)</code>","text":"<p>Data class to represent Billing Baseline Data.</p> <p>Only baseline data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Billing data should have an extra month's data appended at the to denote end of period. (Do not append NaN, any other value would work.)</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of ssues with the data, but none that will severely reduce the quality of the model built.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def __init__(self, df: pd.DataFrame, is_electricity_data: bool):\n    self._df = None\n    self.warnings = []\n    self.disqualification = []\n    self.is_electricity_data = is_electricity_data\n    self.tz = None\n\n    # TODO re-examine dq/warning pattern. keep consistent between\n    # either implicitly setting as side effects, or returning and assigning outside\n    self._df, temp_coverage = self._set_data(df)\n\n    sufficiency_df = self._df.merge(\n        temp_coverage, left_index=True, right_index=True, how=\"left\"\n    )\n    disqualification, warnings = self._check_data_sufficiency(sufficiency_df)\n\n    self.disqualification += disqualification\n    self.warnings += warnings\n    self.log_warnings()\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the Data class from meter data and temperature data.</p> <p>Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe. The temperature column should have values in Fahrenheit.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame</code> <p>The meter data.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data.</p> required <code>is_electricity_data</code> <code>bool</code> <p>A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.</p> required <p>Returns:</p> Type Description <p>An instance of the Data class with the dataframe populated with the corrected data, along with warnings and disqualifications based on the input.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>@classmethod\ndef from_series(\n    cls,\n    meter_data: pd.Series | pd.DataFrame,\n    temperature_data: pd.Series | pd.DataFrame,\n    is_electricity_data: bool,\n):\n    \"\"\"Create an instance of the Data class from meter data and temperature data.\n\n    Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe. The temperature column should have values in Fahrenheit.\n\n    Args:\n        meter_data: The meter data.\n        temperature_data: The temperature data.\n        is_electricity_data: A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.\n\n    Returns:\n        An instance of the Data class with the dataframe populated with the corrected data, along with warnings and disqualifications based on the input.\n    \"\"\"\n    if isinstance(meter_data, pd.Series):\n        meter_data = meter_data.to_frame()\n    if isinstance(temperature_data, pd.Series):\n        temperature_data = temperature_data.to_frame()\n    meter_data = meter_data.rename(columns={meter_data.columns[0]: \"observed\"})\n    temperature_data = temperature_data.rename(\n        columns={temperature_data.columns[0]: \"temperature\"}\n    )\n    temperature_data.index = temperature_data.index.tz_convert(\n        meter_data.index.tzinfo\n    )\n\n    if temperature_data.empty:\n        raise ValueError(\"Temperature data cannot be empty.\")\n    if meter_data.empty:\n        # reporting from_series always passes a full index of nan\n        raise ValueError(\"Meter data cannot by empty.\")\n\n    is_billing_data = False\n    if not meter_data.empty:\n        is_billing_data = compute_minimum_granularity(\n            meter_data.index, \"billing\"\n        ).startswith(\"billing\")\n\n    # first, trim the data to exclude NaNs on the outer edges of the data\n    last_meter_index = meter_data.last_valid_index()\n    if is_billing_data:\n        # preserve final NaN for billing data only\n        last = meter_data.last_valid_index()\n        if last and last != meter_data.index[-1]:\n            # TODO include warning here for non-NaN final billing row since it will be discarded\n            last_meter_index = meter_data.index[meter_data.index.get_loc(last) + 1]\n    meter_data = meter_data.loc[meter_data.first_valid_index() : last_meter_index]\n    temperature_data = temperature_data.loc[\n        temperature_data.first_valid_index() : temperature_data.last_valid_index()\n    ]\n\n    # TODO consider a refactor of the period offset calculation/slicing.\n    # it seems like a fairly dense block of code for something conceptually simple.\n    # at the very least, try to clarify variable names a bit\n\n    period_diff_first = pd.Timedelta(0)\n    period_diff_last = pd.Timedelta(0)\n    # calculate difference in period length for first and last rows in meter/temp\n    # first/last will generally be the same offset for daily/hourly, but billing can be quite variable\n    # could consider using to_offset(index.inferred_freq) if available,\n    # but the intent here is just to provide a lenient first trim.\n    # checking for consistent frequency is done later during __init__\n    if len(meter_data.index) &gt; 1 and len(temperature_data.index) &gt; 1:\n        period_meter_first = meter_data.index[1] - meter_data.index[0]\n        period_temp_first = temperature_data.index[1] - temperature_data.index[0]\n        period_diff_first = period_meter_first - period_temp_first\n\n        period_meter_last = meter_data.index[-1] - meter_data.index[-2]\n        period_temp_last = temperature_data.index[-1] - temperature_data.index[-2]\n        period_diff_last = period_meter_last - period_temp_last\n\n    # if diff is positive, meter period is longer (lower frequency)\n    zero_offset = pd.Timedelta(0)\n    meter_period_first_longer = period_diff_first &gt; zero_offset\n    meter_period_last_longer = period_diff_last &gt; zero_offset\n\n    # large period needs a buffer for the min index, and no buffer for the max index\n    # short period needs a buffer for the max index, and no buffer for the min index\n    meter_offset_first = (\n        period_diff_first if meter_period_first_longer else zero_offset\n    )\n    meter_offset_last = (\n        -period_diff_last if not meter_period_last_longer else zero_offset\n    )\n    temp_offset_first = (\n        -period_diff_first if not meter_period_first_longer else zero_offset\n    )\n    temp_offset_last = period_diff_last if meter_period_last_longer else zero_offset\n\n    # if the shorter period ends on an exact index of the longer, we accept it.\n    # the data should be DQ'd later due to insufficiency for the period\n\n    # constrain meter index to temperature index\n    temp_index_min = temperature_data.index.min() - meter_offset_first\n    temp_index_max = temperature_data.index.max() + meter_offset_last\n    meter_data = meter_data[temp_index_min:temp_index_max]\n    if meter_data.empty:\n        raise ValueError(\"Meter and temperature data are fully misaligned.\")\n\n    # if billing detected, subtract one day from final index since dataframe input assumes final row is part of period\n    if is_billing_data:\n        new_index = meter_data.index[:-1].union(\n            [(meter_data.index[-1] - pd.Timedelta(days=1))]\n        )\n        if len(new_index) == len(meter_data.index):\n            meter_data.index = new_index\n        else:\n            # handles the case of a 1 day off-cycle read at end of series\n            meter_data = meter_data[:-1]\n\n    # constrain temperature index to meter index\n    meter_index_min = meter_data.index.min() - temp_offset_first\n    meter_index_max = meter_data.index.max() + temp_offset_last\n    if is_billing_data and len(meter_data) &gt; 1:\n        # last billing period is offset by one index\n        meter_index_max = meter_data.index[-2] + temp_offset_last\n    temperature_data = temperature_data[meter_index_min:meter_index_max]\n\n    if is_billing_data:\n        # TODO consider adding misaligned data warning here if final row was not already NaN\n        meter_data.iloc[-1] = np.nan\n\n    df = pd.concat([meter_data, temperature_data], axis=1)\n    return cls(df, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingBaselineData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> <p>View the disqualifications and warnings associated with the current data input provided.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def log_warnings(self) -&gt; None:\n    \"\"\"Logs the warnings and disqualifications associated with the data.\n\n    View the disqualifications and warnings associated with the current data input provided.\n\n    Returns:\n        None\n    \"\"\"\n    for warning in self.warnings + self.disqualification:\n        warning.warn()\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData","title":"<code>BillingReportingData(df, is_electricity_data)</code>","text":"<p>Data class to represent Billing Reporting Data.</p> <p>Only reporting data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Meter data input is optional for the reporting class.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of ssues with the data, but none that will severely reduce the quality of the model built.</p> Source code in <code>eemeter/eemeter/models/billing/data.py</code> <pre><code>def __init__(self, df: pd.DataFrame, is_electricity_data: bool):\n    df = df.copy()\n    if \"observed\" not in df.columns:\n        df[\"observed\"] = np.nan\n\n    super().__init__(df, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> <p>View the disqualifications and warnings associated with the current data input provided.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def log_warnings(self) -&gt; None:\n    \"\"\"Logs the warnings and disqualifications associated with the data.\n\n    View the disqualifications and warnings associated with the current data input provided.\n\n    Returns:\n        None\n    \"\"\"\n    for warning in self.warnings + self.disqualification:\n        warning.warn()\n</code></pre>"},{"location":"reference/eemeter/billing_model/#eemeter.eemeter.models.billing.BillingReportingData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data, tzinfo=None)</code>  <code>classmethod</code>","text":"<p>Create a BillingReportingData instance from meter data and temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame | None</code> <p>The meter data to be used for the BillingReportingData instance.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data to be used for the BillingReportingData instance.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag indicating whether the meter data represents electricity data.</p> required <code>tzinfo</code> <code>tzinfo | None</code> <p>Timezone information to be used for the meter data.</p> <code>None</code> <p>Returns:</p> Type Description <p>An instance of the Data class.</p> Source code in <code>eemeter/eemeter/models/billing/data.py</code> <pre><code>@classmethod\ndef from_series(\n    cls,\n    meter_data: pd.Series | pd.DataFrame | None,\n    temperature_data: pd.Series | pd.DataFrame,\n    is_electricity_data: bool,\n    tzinfo: datetime.tzinfo | None = None,\n):\n    \"\"\"Create a BillingReportingData instance from meter data and temperature data.\n\n    Args:\n        meter_data: The meter data to be used for the BillingReportingData instance.\n        temperature_data: The temperature data to be used for the BillingReportingData instance.\n        is_electricity_data: Flag indicating whether the meter data represents electricity data.\n        tzinfo: Timezone information to be used for the meter data.\n\n    Returns:\n        An instance of the Data class.\n    \"\"\"\n    if tzinfo and meter_data is not None:\n        raise ValueError(\n            \"When passing meter data to BillingReportingData, convert its DatetimeIndex to local timezone first; `tzinfo` param should only be used in the absence of reporting meter data.\"\n        )\n    if is_electricity_data is None and meter_data is not None:\n        raise ValueError(\n            \"Must specify is_electricity_data when passing meter data.\"\n        )\n    if meter_data is None:\n        meter_data = pd.DataFrame(\n            {\"observed\": np.nan}, index=temperature_data.index\n        )\n        if tzinfo:\n            meter_data = meter_data.tz_convert(tzinfo)\n    if meter_data.empty:\n        raise ValueError(\n            \"Pass meter_data=None to explicitly create a temperature-only reporting data instance.\"\n        )\n    return super().from_series(meter_data, temperature_data, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/daily_model/","title":"Daily Model","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily","title":"<code>eemeter.eemeter.models.daily</code>","text":"<p>A module housing Daily Model classes and functions.</p> <p>Copyright 2014-2024 OpenEEmeter contributors</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel","title":"<code>DailyModel(model='current', settings=None, verbose=False)</code>","text":"<p>A class to fit a model to the input meter data.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of settings.</p> <code>seasonal_options</code> <code>list</code> <p>A list of seasonal options (su: Summer, sh: Shoulder, wi: Winter). Elements in the list are seasons separated by '_' that represent a model split. For example, a list of ['su_sh', 'wi'] represents two splits: summer/shoulder and winter.</p> <code>day_options</code> <code>list</code> <p>A list of day options.</p> <code>combo_dictionary</code> <code>dict</code> <p>A dictionary of combinations.</p> <code>df_meter</code> <code>DataFrame</code> <p>A dataframe of meter data.</p> <code>error</code> <code>dict</code> <p>A dictionary of error metrics.</p> <code>combinations</code> <code>list</code> <p>A list of combinations.</p> <code>components</code> <code>list</code> <p>A list of components.</p> <code>fit_components</code> <code>list</code> <p>A list of fit components.</p> <code>wRMSE_base</code> <code>float</code> <p>The mean bias error for no splits.</p> <code>best_combination</code> <code>list</code> <p>The best combination of splits.</p> <code>model</code> <code>Pipeline</code> <p>The final fitted model.</p> <code>id</code> <code>str</code> <p>The index of the meter data.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The model to use (either 'current' or 'legacy').</p> <code>'current'</code> <code>settings</code> <code>dict | None</code> <p>DailySettings to be changed.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output.</p> <code>False</code> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def __init__(\n    self,\n    model: str = \"current\",\n    settings: dict | None = None,\n    verbose: bool = False,\n):\n    \"\"\"\n    Args:\n        model: The model to use (either 'current' or 'legacy').\n        settings: DailySettings to be changed.\n        verbose: Whether to print verbose output.\n    \"\"\"\n\n    # Initialize settings\n    # Note: Model designates the base settings, it can be 'current' or 'legacy'\n    #       Settings is to be a dictionary of settings to be changed\n\n    if settings is None:\n        settings = {}\n\n    if model.replace(\" \", \"\").replace(\"_\", \".\").lower() in [\"current\", \"default\"]:\n        self.settings = default_settings(**settings)\n    elif model.replace(\" \", \"\").replace(\"_\", \".\").lower() in [\"legacy\"]:\n        self.settings = caltrack_legacy_settings(**settings)\n    else:\n        raise Exception(\n            \"Invalid 'settings' choice: must be 'current', 'default', or 'legacy'\"\n        )\n\n    # Initialize seasons and weekday/weekend\n    self.seasonal_options = [\n        [\"su_sh_wi\"],\n        [\"su\", \"sh_wi\"],\n        [\"su_sh\", \"wi\"],\n        [\"su_wi\", \"sh\"],\n        [\"su\", \"sh\", \"wi\"],\n    ]\n    self.day_options = [[\"wd\", \"we\"]]\n\n    n_week = list(range(len(self.settings.is_weekday)))\n    self.combo_dictionary = {\n        \"su\": \"summer\",\n        \"sh\": \"shoulder\",\n        \"wi\": \"winter\",\n        \"fw\": [n + 1 for n in n_week],\n        \"wd\": [n + 1 for n in n_week if self.settings.is_weekday[n + 1]],\n        \"we\": [n + 1 for n in n_week if not self.settings.is_weekday[n + 1]],\n    }\n    self.verbose = verbose\n\n    self.error = {\n        \"wRMSE\": np.nan,\n        \"RMSE\": np.nan,\n        \"MAE\": np.nan,\n        \"CVRMSE\": np.nan,\n        \"PNRMSE\": np.nan,\n    }\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.settings","title":"<code>settings = default_settings(**settings)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.seasonal_options","title":"<code>seasonal_options = [['su_sh_wi'], ['su', 'sh_wi'], ['su_sh', 'wi'], ['su_wi', 'sh'], ['su', 'sh', 'wi']]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.day_options","title":"<code>day_options = [['wd', 'we']]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.combo_dictionary","title":"<code>combo_dictionary = {'su': 'summer', 'sh': 'shoulder', 'wi': 'winter', 'fw': [n + 1 for n in n_week], 'wd': [n + 1 for n in n_week if self.settings.is_weekday[n + 1]], 'we': [n + 1 for n in n_week if not self.settings.is_weekday[n + 1]]}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.error","title":"<code>error = {'wRMSE': np.nan, 'RMSE': np.nan, 'MAE': np.nan, 'CVRMSE': np.nan, 'PNRMSE': np.nan}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.fit","title":"<code>fit(baseline_data, ignore_disqualification=False)</code>","text":"<p>Fit the model using baseline data.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_data</code> <code>DailyBaselineData</code> <p>DailyBaselineData object.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore disqualification errors / warnings.</p> <code>False</code> <p>Returns:</p> Type Description <code>DailyModel</code> <p>The fitted model.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If baseline_data is not a DailyBaselineData object.</p> <code>DataSufficiencyError</code> <p>If the model can't be fit on disqualified baseline data.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def fit(\n    self, baseline_data: DailyBaselineData, ignore_disqualification: bool = False\n) -&gt; DailyModel:\n    \"\"\"Fit the model using baseline data.\n\n    Args:\n        baseline_data: DailyBaselineData object.\n        ignore_disqualification: Whether to ignore disqualification errors / warnings.\n\n    Returns:\n        The fitted model.\n\n    Raises:\n        TypeError: If baseline_data is not a DailyBaselineData object.\n        DataSufficiencyError: If the model can't be fit on disqualified baseline data.\n    \"\"\"\n    if not isinstance(baseline_data, DailyBaselineData):\n        raise TypeError(\"baseline_data must be a DailyBaselineData object\")\n    baseline_data.log_warnings()\n    if baseline_data.disqualification and not ignore_disqualification:\n        raise DataSufficiencyError(\"Can't fit model on disqualified baseline data\")\n    self.baseline_timezone = baseline_data.tz\n    self.warnings = baseline_data.warnings\n    self.disqualification = baseline_data.disqualification\n    self._fit(baseline_data.df)\n    if self.error[\"CVRMSE\"] &gt; self.settings.cvrmse_threshold:\n        cvrmse_warning = EEMeterWarning(\n            qualified_name=\"eemeter.model_fit_metrics.cvrmse\",\n            description=(\n                f\"Fit model has CVRMSE &gt; {self.settings.cvrmse_threshold}\"\n            ),\n            data={\"CVRMSE\": self.error[\"CVRMSE\"]},\n        )\n        cvrmse_warning.warn()\n        self.disqualification.append(cvrmse_warning)\n    return self\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.predict","title":"<code>predict(reporting_data, ignore_disqualification=False)</code>","text":"<p>Predicts the energy consumption using the fitted model.</p> <p>Parameters:</p> Name Type Description Default <code>reporting_data</code> <code>Union[DailyBaselineData, DailyReportingData]</code> <p>The data used for prediction.</p> required <code>ignore_disqualification</code> <code>bool</code> <p>Whether to ignore model disqualification. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with input data along with predicted energy consumption.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the model is not fitted.</p> <code>DisqualifiedModelError</code> <p>If the model is disqualified and ignore_disqualification is False.</p> <code>ValueError</code> <p>If the reporting data has a different timezone than the model.</p> <code>TypeError</code> <p>If the reporting data is not of type DailyBaselineData or DailyReportingData.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def predict(\n    self,\n    reporting_data: Union[DailyBaselineData, DailyReportingData],\n    ignore_disqualification=False,\n) -&gt; pd.DataFrame:\n    \"\"\"Predicts the energy consumption using the fitted model.\n\n    Args:\n        reporting_data (Union[DailyBaselineData, DailyReportingData]): The data used for prediction.\n        ignore_disqualification (bool, optional): Whether to ignore model disqualification. Defaults to False.\n\n    Returns:\n        Dataframe with input data along with predicted energy consumption.\n\n    Raises:\n        RuntimeError: If the model is not fitted.\n        DisqualifiedModelError: If the model is disqualified and ignore_disqualification is False.\n        ValueError: If the reporting data has a different timezone than the model.\n        TypeError: If the reporting data is not of type DailyBaselineData or DailyReportingData.\n    \"\"\"\n    if not self.is_fitted:\n        raise RuntimeError(\"Model must be fit before predictions can be made.\")\n\n    if self.disqualification and not ignore_disqualification:\n        raise DisqualifiedModelError(\n            \"Attempting to predict using disqualified model without setting ignore_disqualification=True\"\n        )\n\n    if str(self.baseline_timezone) != str(reporting_data.tz):\n        \"\"\"would be preferable to directly compare, but\n        * using str() helps accomodate mixed tzinfo implementations,\n        * the likelihood of sub-hour offset inconsistencies being relevant to the daily model is low\n        \"\"\"\n        raise ValueError(\n            \"Reporting data must use the same timezone that the model was initially fit on.\"\n        )\n\n    if not isinstance(reporting_data, (DailyBaselineData, DailyReportingData)):\n        raise TypeError(\n            \"reporting_data must be a DailyBaselineData or DailyReportingData object\"\n        )\n\n    return self._predict(reporting_data.df)\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary of model parameters.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Model parameters.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns a dictionary of model parameters.\n\n    Returns:\n        Model parameters.\n    \"\"\"\n    return self.params.model_dump()\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.to_json","title":"<code>to_json()</code>","text":"<p>Returns a JSON string of model parameters.</p> <p>Returns:</p> Type Description <code>str</code> <p>Model parameters.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns a JSON string of model parameters.\n\n    Returns:\n        Model parameters.\n    \"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a instance of the class from a dictionary (such as one produced from the to_dict method).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the model data.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_dict(cls, data) -&gt; DailyModel:\n    \"\"\"Create a instance of the class from a dictionary (such as one produced from the to_dict method).\n\n    Args:\n        data (dict): The dictionary containing the model data.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    settings = data.get(\"settings\")\n    daily_model = cls(settings=settings)\n    info = data.get(\"info\")\n    daily_model.params = DailyModelParameters(\n        submodels=data.get(\"submodels\"),\n        info=info,\n        settings=settings,\n    )\n\n    def deserialize_warnings(warnings):\n        if not warnings:\n            return []\n        warn_list = []\n        for warning in warnings:\n            warn_list.append(\n                EEMeterWarning(\n                    qualified_name=warning.get(\"qualified_name\"),\n                    description=warning.get(\"description\"),\n                    data=warning.get(\"data\"),\n                )\n            )\n        return warn_list\n\n    daily_model.disqualification = deserialize_warnings(\n        info.get(\"disqualification\")\n    )\n    daily_model.warnings = deserialize_warnings(info.get(\"warnings\"))\n    daily_model.baseline_timezone = info.get(\"baseline_timezone\")\n    daily_model.is_fitted = True\n    return daily_model\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.from_json","title":"<code>from_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <code>str</code> <p>The JSON string representing the object.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_json(cls, str_data: str) -&gt; DailyModel:\n    \"\"\"Create an instance of the class from a JSON string.\n\n    Args:\n        str_data: The JSON string representing the object.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    return cls.from_dict(json.loads(str_data))\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.from_2_0_dict","title":"<code>from_2_0_dict(data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a legacy (2.0) model dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing the necessary data (legacy 2.0) to create a DailyModel instance.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_2_0_dict(cls, data) -&gt; DailyModel:\n    \"\"\"Create an instance of the class from a legacy (2.0) model dictionary.\n\n    Args:\n        data (dict): A dictionary containing the necessary data (legacy 2.0) to create a DailyModel instance.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    daily_model = cls(model=\"legacy\")\n    daily_model.params = DailyModelParameters.from_2_0_params(data)\n    daily_model.warnings = []\n    daily_model.disqualification = []\n    daily_model.baseline_timezone = \"UTC\"\n    daily_model.is_fitted = True\n    return daily_model\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.from_2_0_json","title":"<code>from_2_0_json(str_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a legacy (2.0) JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>str_data</code> <code>str</code> <p>The JSON string.</p> required <p>Returns:</p> Type Description <code>DailyModel</code> <p>An instance of the class.</p> Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>@classmethod\ndef from_2_0_json(cls, str_data: str) -&gt; DailyModel:\n    \"\"\"Create an instance of the class from a legacy (2.0) JSON string.\n\n    Args:\n        str_data: The JSON string.\n\n    Returns:\n        An instance of the class.\n\n    \"\"\"\n    return cls.from_2_0_dict(json.loads(str_data))\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyModel.plot","title":"<code>plot(df_eval)</code>","text":"<p>Plot a model fit with baseline or reporting data. Requires matplotlib to use.</p> <p>Parameters:</p> Name Type Description Default <code>df_eval</code> <code>DailyBaselineData | DailyReportingData</code> <p>The baseline or reporting data object to plot.</p> required Source code in <code>eemeter/eemeter/models/daily/model.py</code> <pre><code>def plot(\n    self,\n    df_eval: DailyBaselineData | DailyReportingData,\n) -&gt; None:\n    \"\"\"Plot a model fit with baseline or reporting data. Requires matplotlib to use.\n\n    Args:\n        df_eval: The baseline or reporting data object to plot.\n    \"\"\"\n    try:\n        from eemeter.eemeter.models.daily.plot import plot\n    except ImportError:  # pragma: no cover\n        raise ImportError(\"matplotlib is required for plotting.\")\n\n    # TODO: pass more kwargs to plotting function\n\n    plot(self, self._predict(df_eval.df))\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData","title":"<code>DailyBaselineData(df, is_electricity_data)</code>","text":"<p>Data class to represent Daily Baseline Data.</p> <p>Only baseline data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of ssues with the data, but none that will severely reduce the quality of the model built.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def __init__(self, df: pd.DataFrame, is_electricity_data: bool):\n    self._df = None\n    self.warnings = []\n    self.disqualification = []\n    self.is_electricity_data = is_electricity_data\n    self.tz = None\n\n    # TODO re-examine dq/warning pattern. keep consistent between\n    # either implicitly setting as side effects, or returning and assigning outside\n    self._df, temp_coverage = self._set_data(df)\n\n    sufficiency_df = self._df.merge(\n        temp_coverage, left_index=True, right_index=True, how=\"left\"\n    )\n    disqualification, warnings = self._check_data_sufficiency(sufficiency_df)\n\n    self.disqualification += disqualification\n    self.warnings += warnings\n    self.log_warnings()\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the Data class from meter data and temperature data.</p> <p>Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe. The temperature column should have values in Fahrenheit.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame</code> <p>The meter data.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data.</p> required <code>is_electricity_data</code> <code>bool</code> <p>A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.</p> required <p>Returns:</p> Type Description <p>An instance of the Data class with the dataframe populated with the corrected data, along with warnings and disqualifications based on the input.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>@classmethod\ndef from_series(\n    cls,\n    meter_data: pd.Series | pd.DataFrame,\n    temperature_data: pd.Series | pd.DataFrame,\n    is_electricity_data: bool,\n):\n    \"\"\"Create an instance of the Data class from meter data and temperature data.\n\n    Public method that can can handle two separate series (meter and temperature) and join them to create a single dataframe. The temperature column should have values in Fahrenheit.\n\n    Args:\n        meter_data: The meter data.\n        temperature_data: The temperature data.\n        is_electricity_data: A flag indicating whether the data represents electricity data. This is required as electricity data with 0 values are converted to NaNs.\n\n    Returns:\n        An instance of the Data class with the dataframe populated with the corrected data, along with warnings and disqualifications based on the input.\n    \"\"\"\n    if isinstance(meter_data, pd.Series):\n        meter_data = meter_data.to_frame()\n    if isinstance(temperature_data, pd.Series):\n        temperature_data = temperature_data.to_frame()\n    meter_data = meter_data.rename(columns={meter_data.columns[0]: \"observed\"})\n    temperature_data = temperature_data.rename(\n        columns={temperature_data.columns[0]: \"temperature\"}\n    )\n    temperature_data.index = temperature_data.index.tz_convert(\n        meter_data.index.tzinfo\n    )\n\n    if temperature_data.empty:\n        raise ValueError(\"Temperature data cannot be empty.\")\n    if meter_data.empty:\n        # reporting from_series always passes a full index of nan\n        raise ValueError(\"Meter data cannot by empty.\")\n\n    is_billing_data = False\n    if not meter_data.empty:\n        is_billing_data = compute_minimum_granularity(\n            meter_data.index, \"billing\"\n        ).startswith(\"billing\")\n\n    # first, trim the data to exclude NaNs on the outer edges of the data\n    last_meter_index = meter_data.last_valid_index()\n    if is_billing_data:\n        # preserve final NaN for billing data only\n        last = meter_data.last_valid_index()\n        if last and last != meter_data.index[-1]:\n            # TODO include warning here for non-NaN final billing row since it will be discarded\n            last_meter_index = meter_data.index[meter_data.index.get_loc(last) + 1]\n    meter_data = meter_data.loc[meter_data.first_valid_index() : last_meter_index]\n    temperature_data = temperature_data.loc[\n        temperature_data.first_valid_index() : temperature_data.last_valid_index()\n    ]\n\n    # TODO consider a refactor of the period offset calculation/slicing.\n    # it seems like a fairly dense block of code for something conceptually simple.\n    # at the very least, try to clarify variable names a bit\n\n    period_diff_first = pd.Timedelta(0)\n    period_diff_last = pd.Timedelta(0)\n    # calculate difference in period length for first and last rows in meter/temp\n    # first/last will generally be the same offset for daily/hourly, but billing can be quite variable\n    # could consider using to_offset(index.inferred_freq) if available,\n    # but the intent here is just to provide a lenient first trim.\n    # checking for consistent frequency is done later during __init__\n    if len(meter_data.index) &gt; 1 and len(temperature_data.index) &gt; 1:\n        period_meter_first = meter_data.index[1] - meter_data.index[0]\n        period_temp_first = temperature_data.index[1] - temperature_data.index[0]\n        period_diff_first = period_meter_first - period_temp_first\n\n        period_meter_last = meter_data.index[-1] - meter_data.index[-2]\n        period_temp_last = temperature_data.index[-1] - temperature_data.index[-2]\n        period_diff_last = period_meter_last - period_temp_last\n\n    # if diff is positive, meter period is longer (lower frequency)\n    zero_offset = pd.Timedelta(0)\n    meter_period_first_longer = period_diff_first &gt; zero_offset\n    meter_period_last_longer = period_diff_last &gt; zero_offset\n\n    # large period needs a buffer for the min index, and no buffer for the max index\n    # short period needs a buffer for the max index, and no buffer for the min index\n    meter_offset_first = (\n        period_diff_first if meter_period_first_longer else zero_offset\n    )\n    meter_offset_last = (\n        -period_diff_last if not meter_period_last_longer else zero_offset\n    )\n    temp_offset_first = (\n        -period_diff_first if not meter_period_first_longer else zero_offset\n    )\n    temp_offset_last = period_diff_last if meter_period_last_longer else zero_offset\n\n    # if the shorter period ends on an exact index of the longer, we accept it.\n    # the data should be DQ'd later due to insufficiency for the period\n\n    # constrain meter index to temperature index\n    temp_index_min = temperature_data.index.min() - meter_offset_first\n    temp_index_max = temperature_data.index.max() + meter_offset_last\n    meter_data = meter_data[temp_index_min:temp_index_max]\n    if meter_data.empty:\n        raise ValueError(\"Meter and temperature data are fully misaligned.\")\n\n    # if billing detected, subtract one day from final index since dataframe input assumes final row is part of period\n    if is_billing_data:\n        new_index = meter_data.index[:-1].union(\n            [(meter_data.index[-1] - pd.Timedelta(days=1))]\n        )\n        if len(new_index) == len(meter_data.index):\n            meter_data.index = new_index\n        else:\n            # handles the case of a 1 day off-cycle read at end of series\n            meter_data = meter_data[:-1]\n\n    # constrain temperature index to meter index\n    meter_index_min = meter_data.index.min() - temp_offset_first\n    meter_index_max = meter_data.index.max() + temp_offset_last\n    if is_billing_data and len(meter_data) &gt; 1:\n        # last billing period is offset by one index\n        meter_index_max = meter_data.index[-2] + temp_offset_last\n    temperature_data = temperature_data[meter_index_min:meter_index_max]\n\n    if is_billing_data:\n        # TODO consider adding misaligned data warning here if final row was not already NaN\n        meter_data.iloc[-1] = np.nan\n\n    df = pd.concat([meter_data, temperature_data], axis=1)\n    return cls(df, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyBaselineData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> <p>View the disqualifications and warnings associated with the current data input provided.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def log_warnings(self) -&gt; None:\n    \"\"\"Logs the warnings and disqualifications associated with the data.\n\n    View the disqualifications and warnings associated with the current data input provided.\n\n    Returns:\n        None\n    \"\"\"\n    for warning in self.warnings + self.disqualification:\n        warning.warn()\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData","title":"<code>DailyReportingData(df, is_electricity_data)</code>","text":"<p>Data class to represent Daily Reporting Data.</p> <p>Only reporting data should go into the dataframe input, no blackout data should be input. Checks sufficiency for the data provided as input depending on OpenEEMeter specifications and populates disqualifications and warnings based on it.</p> <p>Meter data input is optional for the reporting class.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe having a datetime index or a datetime column with the timezone also being set. It also requires 2 more columns - 'observed' for meter data, and 'temperature' for temperature data. The temperature column should have values in Fahrenheit. Please convert your temperatures accordingly.</p> required <code>is_electricity_data</code> <code>bool</code> <p>Flag to ascertain if this is electricity data or not. Electricity data values of 0 are set to NaN.</p> required <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Immutable dataframe that contains the meter and temperature values for the baseline data period.</p> <code>disqualification</code> <code>list[EEMeterWarning]</code> <p>A list of serious issues with the data that can degrade the quality of the model. If you want to go ahead with building the model while ignoring them, set the ignore_disqualification = True flag in the model. By default disqualifications are not ignored.</p> <code>warnings</code> <code>list[EEMeterWarning]</code> <p>A list of ssues with the data, but none that will severely reduce the quality of the model built.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def __init__(self, df: pd.DataFrame, is_electricity_data: bool):\n    df = df.copy()\n    if \"observed\" not in df.columns:\n        df[\"observed\"] = np.nan\n\n    super().__init__(df, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData.warnings","title":"<code>warnings = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData.disqualification","title":"<code>disqualification = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData.is_electricity_data","title":"<code>is_electricity_data = is_electricity_data</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData.tz","title":"<code>tz = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData.df","title":"<code>df: pd.DataFrame | None</code>  <code>property</code>","text":"<p>Get the corrected input data stored in the class. The actual dataframe is immutable, this returns a copy.</p>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData.log_warnings","title":"<code>log_warnings()</code>","text":"<p>Logs the warnings and disqualifications associated with the data.</p> <p>View the disqualifications and warnings associated with the current data input provided.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>def log_warnings(self) -&gt; None:\n    \"\"\"Logs the warnings and disqualifications associated with the data.\n\n    View the disqualifications and warnings associated with the current data input provided.\n\n    Returns:\n        None\n    \"\"\"\n    for warning in self.warnings + self.disqualification:\n        warning.warn()\n</code></pre>"},{"location":"reference/eemeter/daily_model/#eemeter.eemeter.models.daily.DailyReportingData.from_series","title":"<code>from_series(meter_data, temperature_data, is_electricity_data=None, tzinfo=None)</code>  <code>classmethod</code>","text":"<p>Create an instance of the Data class from meter data and temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>Series | DataFrame | None</code> <p>The meter data to be used for the DailyReportingData instance.</p> required <code>temperature_data</code> <code>Series | DataFrame</code> <p>The temperature data to be used for the DailyReportingData instance.</p> required <code>is_electricity_data</code> <code>bool | None</code> <p>Flag indicating whether the meter data represents electricity data.</p> <code>None</code> <code>tzinfo</code> <code>tzinfo | None</code> <p>Timezone information to be used for the meter data.</p> <code>None</code> <p>Returns:</p> Type Description <code>DailyReportingData</code> <p>An instance of the Data class.</p> Source code in <code>eemeter/eemeter/models/daily/data.py</code> <pre><code>@classmethod\ndef from_series(\n    cls,\n    meter_data: pd.Series | pd.DataFrame | None,\n    temperature_data: pd.Series | pd.DataFrame,\n    is_electricity_data: bool | None = None,\n    tzinfo: datetime.tzinfo | None = None,\n) -&gt; DailyReportingData:\n    \"\"\"Create an instance of the Data class from meter data and temperature data.\n\n    Args:\n        meter_data: The meter data to be used for the DailyReportingData instance.\n        temperature_data: The temperature data to be used for the DailyReportingData instance.\n        is_electricity_data: Flag indicating whether the meter data represents electricity data.\n        tzinfo: Timezone information to be used for the meter data.\n\n    Returns:\n        An instance of the Data class.\n    \"\"\"\n    if tzinfo and meter_data is not None:\n        raise ValueError(\n            \"When passing meter data to DailyReportingData, convert its DatetimeIndex to local timezone first; `tzinfo` param should only be used in the absence of reporting meter data.\"\n        )\n    if is_electricity_data is None and meter_data is not None:\n        raise ValueError(\n            \"Must specify is_electricity_data when passing meter data.\"\n        )\n    if meter_data is None:\n        meter_data = pd.DataFrame(\n            {\"observed\": np.nan}, index=temperature_data.index\n        )\n        if tzinfo:\n            meter_data = meter_data.tz_convert(tzinfo)\n\n        # If is_electricity_data is not specified, set it to True for proper functioning in the parent class. If it hits this point it's all NaNs anyway.\n        if is_electricity_data is None:\n            is_electricity_data = True\n    if meter_data.empty:\n        raise ValueError(\n            \"Pass meter_data=None rather than an empty series in order to explicitly create a temperature-only reporting data instance.\"\n        )\n    return super().from_series(meter_data, temperature_data, is_electricity_data)\n</code></pre>"},{"location":"reference/eemeter/daily_model_settings/","title":"Daily Model Settings","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config","title":"<code>eemeter.eemeter.models.daily.utilities.config</code>","text":"<p>Copyright 2014-2024 OpenEEmeter contributors</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings","title":"<code>DailySettings</code>","text":"<p>Settings for creating the daily model.</p> <p>These settings should be converted to a dictionary before being passed to the DailyModel class. Be advised that any changes to the default settings deviates from OpenEEmeter standard methods and should be used with caution.</p> <p>Attributes:</p> Name Type Description <code>developer_mode</code> <code>bool</code> <p>Allows changing of developer settings</p> <code>algorithm_choice</code> <code>str</code> <p>Optimization algorithm choice. Developer mode only.</p> <code>initial_guess_algorithm_choice</code> <code>str</code> <p>Initial guess optimization algorithm choice. Developer mode only.</p> <code>full_model</code> <code>str</code> <p>The largest model allowed. Developer mode only.</p> <code>smoothed_model</code> <code>bool</code> <p>Allow smoothed models.</p> <code>allow_separate_summer</code> <code>bool</code> <p>Allow summer to be modeled separately.</p> <code>allow_separate_shoulder</code> <code>bool</code> <p>Allow shoulder to be modeled separately.</p> <code>allow_separate_winter</code> <code>bool</code> <p>Allow winter to be modeled separately.</p> <code>allow_separate_weekday_weekend</code> <code>bool</code> <p>Allow weekdays and weekends to be modeled separately.</p> <code>reduce_splits_by_gaussian</code> <code>bool</code> <p>Reduces splits by fitting with multivariate Gaussians and testing for overlap.</p> <code>reduce_splits_num_std</code> <code>list[float]</code> <p>Number of standard deviations to use with Gaussians.</p> <code>alpha_minimum</code> <code>float</code> <p>Alpha where adaptive robust loss function is Welsch loss.</p> <code>alpha_selection</code> <code>float</code> <p>Specified alpha to evaluate which is the best model type.</p> <code>alpha_final_type</code> <code>str</code> <p>When to use 'alpha_final: 'all': on every model, 'last': on final model, 'None': don't use.</p> <code>alpha_final</code> <code>float | str | None</code> <p>Specified alpha or 'adaptive' for adaptive loss in model evaluation.</p> <code>final_bounds_scalar</code> <code>float | None</code> <p>Scalar for calculating bounds of 'alpha_final'.</p> <code>regularization_alpha</code> <code>float</code> <p>Alpha for elastic net regularization.</p> <code>regularization_percent_lasso</code> <code>float</code> <p>Percent lasso vs (1 - perc) ridge regularization.</p> <code>segment_minimum_count</code> <code>int</code> <p>Minimum number of data points for HDD/CDD.</p> <code>maximum_slope_OoM_scaler</code> <code>float</code> <p>Scaler for initial slope to calculate bounds based on order of magnitude.</p> <code>initial_smoothing_parameter</code> <code>float | None</code> <p>Initial guess for the smoothing parameter.</p> <code>initial_step_percentage</code> <code>float | None</code> <p>Initial step-size for relevant algorithms.</p> <code>split_selection_criteria</code> <code>str</code> <p>What selection criteria is used to select data splits of models.</p> <code>split_selection_penalty_multiplier</code> <code>float</code> <p>Penalty multiplier for split selection criteria.</p> <code>split_selection_penalty_power</code> <code>float</code> <p>What power should the penalty of the selection criteria be raised to.</p> <code>season</code> <code>Dict[int, str]</code> <p>Dictionary of months and their associated season (January is 1).</p> <code>is_weekday</code> <code>Dict[int, bool]</code> <p>Dictionary of days (1 = Monday) and if that day is a weekday (True/False).</p> <code>uncertainty_alpha</code> <code>float</code> <p>Significance level used for uncertainty calculations (0 &lt; float &lt; 1).</p> <code>cvrmse_threshold</code> <code>float</code> <p>Threshold for the CVRMSE to disqualify a model.</p>"},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.developer_mode","title":"<code>developer_mode: bool = attrs.field(validator=simple_validation(lambda x: isinstance(x, bool)), metadata={_KEY_DESCR: 'allows changing of developer settings'}, default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.algorithm_choice","title":"<code>algorithm_choice: str = attrs.field(converter=lambda x: x.lower() if isinstance(x, str) else x, validator=developer_mode_validation(algorithm_choice_validator), metadata={_KEY_DESCR: 'optimization algorithm choice'}, on_setattr=attrs.setters.frozen, default=AlgorithmChoice.NLOPT_SBPLX.lower())</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.initial_guess_algorithm_choice","title":"<code>initial_guess_algorithm_choice: str = attrs.field(converter=lambda x: x.lower() if isinstance(x, str) else x, validator=developer_mode_validation(algorithm_choice_validator), metadata={_KEY_DESCR: 'initial guess optimization algorithm choice'}, on_setattr=attrs.setters.frozen, default=AlgorithmChoice.NLOPT_DIRECT.lower())</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.full_model","title":"<code>full_model: str = attrs.field(converter=lambda x: x.lower() if isinstance(x, str) else x, validator=developer_mode_validation(full_model_validator), metadata={_KEY_DESCR: 'the largest model allowed'}, on_setattr=attrs.setters.frozen, default=FullModelSelection.HDD_TIDD_CDD)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.smoothed_model","title":"<code>smoothed_model: bool = attrs.field(validator=simple_validation(lambda x: isinstance(x, bool), dev_setting=True), metadata={_KEY_DESCR: 'allow smoothed models'}, on_setattr=attrs.setters.frozen, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.allow_separate_summer","title":"<code>allow_separate_summer: bool = attrs.field(validator=simple_validation(lambda x: isinstance(x, bool), dev_setting=True), metadata={_KEY_DESCR: 'allow summer to be modeled separately'}, on_setattr=attrs.setters.frozen, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.allow_separate_shoulder","title":"<code>allow_separate_shoulder: bool = attrs.field(validator=simple_validation(lambda x: isinstance(x, bool), dev_setting=True), metadata={_KEY_DESCR: 'allow shoulder to be modeled separately'}, on_setattr=attrs.setters.frozen, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.allow_separate_winter","title":"<code>allow_separate_winter: bool = attrs.field(validator=simple_validation(lambda x: isinstance(x, bool), dev_setting=True), metadata={_KEY_DESCR: 'allow winter to be modeled separately'}, on_setattr=attrs.setters.frozen, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.allow_separate_weekday_weekend","title":"<code>allow_separate_weekday_weekend: bool = attrs.field(validator=simple_validation(lambda x: isinstance(x, bool), dev_setting=True), metadata={_KEY_DESCR: 'allow weekdays and weekends to be modeled separately'}, on_setattr=attrs.setters.frozen, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.reduce_splits_by_gaussian","title":"<code>reduce_splits_by_gaussian: bool = attrs.field(validator=simple_validation(lambda x: isinstance(x, bool), dev_setting=True), metadata={_KEY_DESCR: 'reduces splits by fitting with multivariate Gaussians and testing for overlap'}, on_setattr=attrs.setters.frozen, default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.reduce_splits_num_std","title":"<code>reduce_splits_num_std: list[float] = attrs.field(metadata={_KEY_DESCR: 'number of standard deviations to use with Gaussians'}, on_setattr=attrs.setters.frozen, default=[1.4, 0.89])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.alpha_minimum","title":"<code>alpha_minimum: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: isinstance(x, float) and x &lt;= -10, \"'alpha_minimum', must be float &lt; -10\", dev_setting=True), metadata={_KEY_DESCR: 'alpha where adaptive robust loss function is Welsch loss'}, on_setattr=attrs.setters.frozen, default=-100)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.alpha_selection","title":"<code>alpha_selection: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: isinstance(x, float) and -10 &lt;= x and x &lt;= 2, \"'alpha_selection' must be -10 &lt;= float &lt;= 2\", dev_setting=True), metadata={_KEY_DESCR: 'specified alpha to evaluate which is the best model type'}, on_setattr=attrs.setters.frozen, default=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.alpha_final_type","title":"<code>alpha_final_type: str = attrs.field(converter=lambda x: x.lower() if isinstance(x, str) else x, validator=developer_mode_validation(attrs.validators.in_(get_pub_class_attrib_values(AlphaFinalType))), metadata={_KEY_DESCR: \"when to use 'alpha_final: 'all': on every model, 'last': on final model, 'None': don't use\"}, on_setattr=attrs.setters.frozen, default='last')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.alpha_final","title":"<code>alpha_final: float | str | None = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=developer_mode_validation(alpha_final_validator), metadata={_KEY_DESCR: \"specified alpha or 'adaptive' for adaptive loss in model evaluation\"}, on_setattr=attrs.setters.frozen, default='adaptive')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.final_bounds_scalar","title":"<code>final_bounds_scalar: float | None = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=developer_mode_validation(final_bounds_scalar_validator), metadata={_KEY_DESCR: \"scalar for calculating bounds of 'alpha_final'\"}, on_setattr=attrs.setters.frozen, default=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.regularization_alpha","title":"<code>regularization_alpha: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: 0 &lt;= x, \"'regularization_alpha' must be 0 &lt;= float\", dev_setting=True), metadata={_KEY_DESCR: 'alpha for elastic net regularization'}, on_setattr=attrs.setters.frozen, default=0.001)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.regularization_percent_lasso","title":"<code>regularization_percent_lasso: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: 0 &lt;= x and x &lt;= 1, \"'regularization_percent_lasso' must be 0 &lt;= float &lt;= 1\", dev_setting=True), metadata={_KEY_DESCR: 'percent lasso vs (1 - perc) ridge regularization'}, on_setattr=attrs.setters.frozen, default=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.segment_minimum_count","title":"<code>segment_minimum_count: int = attrs.field(converter=lambda x: int(x) if isinstance(x, float) else x, validator=simple_validation(lambda x: isinstance(x, int) and 3 &lt;= x, \"'segment_minimum_count' must be 3 &lt;= int\", dev_setting=True), metadata={_KEY_DESCR: 'minimum number of data points for HDD/CDD'}, on_setattr=attrs.setters.frozen, default=6)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.maximum_slope_OoM_scaler","title":"<code>maximum_slope_OoM_scaler: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: isinstance(x, float) and 0 &lt; x, \"'maximum_slope_OoM_scaler' must be 0 &lt; float\", dev_setting=True), metadata={_KEY_DESCR: 'scaler for initial slope to calculate bounds based on order of magnitude'}, on_setattr=attrs.setters.frozen, default=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.initial_smoothing_parameter","title":"<code>initial_smoothing_parameter: float | None = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=developer_mode_validation(initial_smoothing_parameter_validator), metadata={_KEY_DESCR: 'initial guess for the smoothing parameter'}, on_setattr=attrs.setters.frozen, default=0.5)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.initial_step_percentage","title":"<code>initial_step_percentage: float | None = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=developer_mode_validation(initial_step_percentage_validator), metadata={_KEY_DESCR: 'initial step-size for relevant algorithms'}, on_setattr=attrs.setters.frozen, default=0.1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.split_selection_criteria","title":"<code>split_selection_criteria: str = attrs.field(converter=lambda x: x.lower() if isinstance(x, str) else x, validator=attrs.validators.in_(get_pub_class_attrib_values(ModelSelectionCriteria)), metadata={_KEY_DESCR: 'what selection criteria is used to select data splits of models'}, on_setattr=attrs.setters.frozen, default='bic')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.split_selection_penalty_multiplier","title":"<code>split_selection_penalty_multiplier: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: isinstance(x, float) and 0 &lt;= x, 'must be 0 &lt;= float', dev_setting=True), metadata={_KEY_DESCR: 'what multiplier should be applied to the penalty of the selection criteria'}, on_setattr=attrs.setters.frozen, default=0.24)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.split_selection_penalty_power","title":"<code>split_selection_penalty_power: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: isinstance(x, float) and 0 &lt;= x, 'must be 0 &lt;= float', dev_setting=True), metadata={_KEY_DESCR: 'what power should the penalty of the selection criteria be raised to'}, on_setattr=attrs.setters.frozen, default=2.061)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.season","title":"<code>season: Dict[int, str] = attrs.field(converter=lambda x: {int(k): str(v).lower().strip()for (k, v) in x.items()}, validator=season_choice_validator, metadata={_KEY_DESCR: 'dictionary of months and their associated season (January is 1)'}, on_setattr=attrs.setters.frozen, default={1: 'winter', 2: 'winter', 3: 'shoulder', 4: 'shoulder', 5: 'shoulder', 6: 'summer', 7: 'summer', 8: 'summer', 9: 'summer', 10: 'shoulder', 11: 'winter', 12: 'winter'})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.is_weekday","title":"<code>is_weekday: Dict[int, bool] = attrs.field(validator=is_weekday_validator, converter=lambda x: {int(k): vfor (k, v) in x.items()}, metadata={_KEY_DESCR: 'dictionary of days (1 = Monday) and if that day is a weekday (True/False)'}, on_setattr=attrs.setters.frozen, default={1: True, 2: True, 3: True, 4: True, 5: True, 6: False, 7: False})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.uncertainty_alpha","title":"<code>uncertainty_alpha: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: isinstance(x, float) and 0 &lt; x and x &lt; 1, \"'uncertainty_alpha' must be 0 &lt; float &lt; 1\", dev_setting=False), metadata={_KEY_DESCR: 'significance level used for uncertainty calculations (0 &lt; float &lt; 1)'}, on_setattr=attrs.setters.frozen, default=0.1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.cvrmse_threshold","title":"<code>cvrmse_threshold: float = attrs.field(converter=lambda x: float(x) if isinstance(x, int) else x, validator=simple_validation(lambda x: isinstance(x, float) and 0 &lt; x, \"'cvrmse_threshold' must be 0 &lt; float\", dev_setting=False), metadata={_KEY_DESCR: 'threshold for the CVRMSE to disqualify a model'}, on_setattr=attrs.setters.frozen, default=1.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/eemeter/daily_model_settings/#eemeter.eemeter.models.daily.utilities.config.DailySettings.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts an instance of the class into a python dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the class instance.</p> Source code in <code>eemeter/eemeter/models/daily/utilities/config.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Converts an instance of the class into a python dictionary.\n\n    Returns:\n        A dictionary of the class instance.\n    \"\"\"\n    keys = []\n    config = {}\n    for key in dir(self):\n        if not key.startswith(\"_\") and key != \"to_dict\":\n            keys.append(key)\n    for key in keys:\n        config[key] = getattr(self, key)\n    return config\n</code></pre>"},{"location":"reference/eemeter/hourly_model/","title":"Hourly Model","text":"<p>The hourly model is currently receiving an overhaul and updated documentation is coming soon.</p>"},{"location":"reference/eemeter/utilities/","title":"Utilities","text":""},{"location":"reference/eemeter/utilities/#eemeter.eemeter.utilities.io","title":"<code>eemeter.eemeter.utilities.io</code>","text":"<p>A module for assiting with input/output operations.</p> <p>Copyright 2014-2024 OpenEEmeter contributors</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/eemeter/utilities/#eemeter.eemeter.utilities.io.meter_data_from_csv","title":"<code>meter_data_from_csv(filepath_or_buffer, tz=None, start_col='start', value_col='value', gzipped=False, freq=None, **kwargs)</code>","text":"<p>Load meter data from a CSV file and convert to a dataframe.</p> This is an example of the default csv structure assumed. <pre><code>start,value\n2017-01-01T00:00:00+00:00,0.31\n2017-01-02T00:00:00+00:00,0.4\n2017-01-03T00:00:00+00:00,0.58\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filepath_or_buffer</code> <code>str | FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]</code> <p>File path or object.</p> required <code>tz</code> <code>str | tzinfo | None</code> <p>Timezone represented in the meter data. Ex: <code>UTC</code> or <code>US/Pacific</code></p> <code>None</code> <code>start_col</code> <code>str</code> <p>Date period start column.</p> <code>'start'</code> <code>value_col</code> <code>str</code> <p>Value column, can be in any unit.</p> <code>'value'</code> <code>gzipped</code> <code>bool</code> <p>Whether file is gzipped.</p> <code>False</code> <code>freq</code> <code>str | None</code> <p>If given, apply frequency to data using <code>pandas.DataFrame.resample</code>. One of <code>['hourly', 'daily']</code>.</p> <code>None</code> <code>**kwargs</code> <p>Extra keyword arguments to pass to <code>pandas.read_csv</code>, such as <code>sep='|'</code>.</p> <code>{}</code> Source code in <code>eemeter/eemeter/utilities/io.py</code> <pre><code>def meter_data_from_csv(\n    filepath_or_buffer: str | FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str],\n    tz: str | datetime.tzinfo | None = None,\n    start_col: str = \"start\",\n    value_col: str = \"value\",\n    gzipped: bool = False,\n    freq: str | None = None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"Load meter data from a CSV file and convert to a dataframe.\n\n    Note: This is an example of the default csv structure assumed.\n        ```python\n        start,value\n        2017-01-01T00:00:00+00:00,0.31\n        2017-01-02T00:00:00+00:00,0.4\n        2017-01-03T00:00:00+00:00,0.58\n        ```\n\n    Args:\n        filepath_or_buffer: File path or object.\n        tz: Timezone represented in the meter data. Ex: `UTC` or `US/Pacific`\n        start_col: Date period start column.\n        value_col: Value column, can be in any unit.\n        gzipped: Whether file is gzipped.\n        freq: If given, apply frequency to data using `pandas.DataFrame.resample`. One of `['hourly', 'daily']`.\n        **kwargs: Extra keyword arguments to pass to `pandas.read_csv`, such as `sep='|'`.\n    \"\"\"\n\n    read_csv_kwargs = {\n        \"usecols\": [start_col, value_col],\n        \"dtype\": {value_col: np.float64},\n        \"parse_dates\": [start_col],\n        \"index_col\": start_col,\n    }\n\n    if gzipped:\n        read_csv_kwargs.update({\"compression\": \"gzip\"})\n\n    # allow passing extra kwargs\n    read_csv_kwargs.update(kwargs)\n\n    df = pd.read_csv(filepath_or_buffer, **read_csv_kwargs)\n    df.index = pd.to_datetime(df.index, utc=True)\n\n    # for pandas&lt;0.24, which doesn't localize even with utc=True\n    if df.index.tz is None:\n        df.index = df.index.tz_localize(\"UTC\")  # pragma: no cover\n\n    if tz is not None:\n        df = df.tz_convert(tz)\n\n    if freq == \"hourly\":\n        df = df.resample(\"H\").sum(min_count=1)\n    elif freq == \"daily\":\n        df = df.resample(\"D\").sum(min_count=1)\n\n    return df\n</code></pre>"},{"location":"reference/eemeter/utilities/#eemeter.eemeter.utilities.io.temperature_data_from_csv","title":"<code>temperature_data_from_csv(filepath_or_buffer, tz=None, date_col='dt', temp_col='tempF', gzipped=False, freq=None, **kwargs)</code>","text":"<p>Load meter data from a CSV file and convert to a dataframe. Farenheit is assumed for building models.</p> This is an example of the default csv structure assumed. <pre><code>dt,tempF\n2017-01-01T00:00:00+00:00,21\n2017-01-01T01:00:00+00:00,22.5\n2017-01-01T02:00:00+00:00,23.5\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filepath_or_buffer</code> <code>str | FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]</code> <p>File path or object.</p> required <code>tz</code> <code>str | tzinfo | None</code> <p>Timezone represented in the meter data. Ex: <code>UTC</code> or <code>US/Pacific</code></p> <code>None</code> <code>date_col</code> <code>str</code> <p>Date period start column.</p> <code>'dt'</code> <code>temp_col</code> <code>str</code> <p>Temperature column.</p> <code>'tempF'</code> <code>gzipped</code> <code>bool</code> <p>Whether file is gzipped.</p> <code>False</code> <code>freq</code> <code>str | None</code> <p>If given, apply frequency to data using <code>pandas.DataFrame.resample</code>. One of <code>['hourly', 'daily']</code>.</p> <code>None</code> <code>**kwargs</code> <p>Extra keyword arguments to pass to <code>pandas.read_csv</code>, such as <code>sep='|'</code>.</p> <code>{}</code> Source code in <code>eemeter/eemeter/utilities/io.py</code> <pre><code>def temperature_data_from_csv(\n    filepath_or_buffer: str | FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str],\n    tz: str | datetime.tzinfo | None = None,\n    date_col: str = \"dt\",\n    temp_col: str = \"tempF\",\n    gzipped: bool = False,\n    freq: str | None = None,\n    **kwargs,\n):\n    \"\"\"Load meter data from a CSV file and convert to a dataframe. Farenheit is assumed for building models.\n\n    Note: This is an example of the default csv structure assumed.\n        ```python\n        dt,tempF\n        2017-01-01T00:00:00+00:00,21\n        2017-01-01T01:00:00+00:00,22.5\n        2017-01-01T02:00:00+00:00,23.5\n        ```\n\n    Args:\n        filepath_or_buffer: File path or object.\n        tz: Timezone represented in the meter data. Ex: `UTC` or `US/Pacific`\n        date_col: Date period start column.\n        temp_col: Temperature column.\n        gzipped: Whether file is gzipped.\n        freq: If given, apply frequency to data using `pandas.DataFrame.resample`. One of `['hourly', 'daily']`.\n        **kwargs: Extra keyword arguments to pass to `pandas.read_csv`, such as `sep='|'`.\n    \"\"\"\n    read_csv_kwargs = {\n        \"usecols\": [date_col, temp_col],\n        \"dtype\": {temp_col: np.float64},\n        \"parse_dates\": [date_col],\n        \"index_col\": date_col,\n    }\n\n    if gzipped:\n        read_csv_kwargs.update({\"compression\": \"gzip\"})\n\n    # allow passing extra kwargs\n    read_csv_kwargs.update(kwargs)\n\n    df = pd.read_csv(filepath_or_buffer, **read_csv_kwargs)\n    df.index = pd.to_datetime(df.index, utc=True)\n\n    # for pandas&lt;0.24, which doesn't localize even with utc=True\n    if df.index.tz is None:\n        df.index = df.index.tz_localize(\"UTC\")  # pragma: no cover\n\n    if tz is not None:\n        df = df.tz_convert(tz)\n\n    if freq == \"hourly\":\n        df = df.resample(\"H\").sum(min_count=1)\n\n    return df[temp_col]\n</code></pre>"},{"location":"reference/eemeter/utilities/#eemeter.eemeter.utilities.io.meter_data_from_json","title":"<code>meter_data_from_json(data, orient='list')</code>","text":"<p>Load meter data from a list of dictionary objects or a list of lists.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>A list of meter data, with each row representing a single record.</p> required <code>orient</code> <code>str</code> <p>Format of <code>data</code> parameter. Must be one of <code>['list', 'records']</code>. <code>'list'</code> is a list of lists, with the first element as start date and the second element as meter usage. <code>'records'</code> is a list of dicts.</p> <code>'list'</code> This is an example of the default <code>list</code> structure. <pre><code>[\n    ['2017-01-01T00:00:00+00:00', 3.5],\n    ['2017-02-01T00:00:00+00:00', 0.4],\n    ['2017-03-01T00:00:00+00:00', 0.46],\n]\n</code></pre> This is an example of the <code>records</code> structure. <pre><code>[\n    {'start': '2017-01-01T00:00:00+00:00', 'value': 3.5},\n    {'start': '2017-02-01T00:00:00+00:00', 'value': 0.4},\n    {'start': '2017-03-01T00:00:00+00:00', 'value': 0.46},\n]\n</code></pre> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with a single column (<code>'value'</code>) and a <code>pandas.DatetimeIndex</code>. A second column (<code>'estimated'</code>) may also be included if the input data contained an estimated boolean flag.</p> Source code in <code>eemeter/eemeter/utilities/io.py</code> <pre><code>def meter_data_from_json(data: list, orient: str = \"list\") -&gt; pd.DataFrame:\n    \"\"\"Load meter data from a list of dictionary objects or a list of lists.\n\n    Args:\n        data: A list of meter data, with each row representing a single record.\n        orient: Format of `data` parameter. Must be one of `['list', 'records']`.\n            `'list'` is a list of lists, with the first element as start date and the second element as meter usage. `'records'` is a list of dicts.\n\n    Note: This is an example of the default `list` structure.\n        ```python\n        [\n            ['2017-01-01T00:00:00+00:00', 3.5],\n            ['2017-02-01T00:00:00+00:00', 0.4],\n            ['2017-03-01T00:00:00+00:00', 0.46],\n        ]\n        ```\n\n    Note: This is an example of the `records` structure.\n        ```python\n        [\n            {'start': '2017-01-01T00:00:00+00:00', 'value': 3.5},\n            {'start': '2017-02-01T00:00:00+00:00', 'value': 0.4},\n            {'start': '2017-03-01T00:00:00+00:00', 'value': 0.46},\n        ]\n        ```\n\n    Returns:\n        DataFrame with a single column (``'value'``) and a `pandas.DatetimeIndex`. A second column (``'estimated'``) may also be included if the input data contained an estimated boolean flag.\n    \"\"\"\n\n    def _empty_meter_data_dataframe():\n        return pd.DataFrame(\n            {\"value\": []}, index=pd.DatetimeIndex([], tz=\"UTC\", name=\"start\")\n        )\n\n    if data is None:\n        return _empty_meter_data_dataframe()\n\n    if orient == \"list\":\n        df = pd.DataFrame(data, columns=[\"start\", \"value\"])\n        df[\"start\"] = pd.to_datetime(df.start, utc=True)\n        df = df.set_index(\"start\")\n        return df\n    elif orient == \"records\":\n\n        def _noneify_meter_data_row(row):\n            value = row[\"value\"]\n            if value is not None:\n                try:\n                    value = float(value)\n                except ValueError:\n                    value = None\n            out_row = {\"start\": row[\"start\"], \"value\": value}\n            if \"estimated\" in row:\n                estimated = row.get(\"estimated\")\n                out_row[\"estimated\"] = estimated in [True, \"true\", \"True\", 1, \"1\"]\n            return out_row\n\n        noneified_data = [_noneify_meter_data_row(row) for row in data]\n        df = pd.DataFrame(noneified_data)\n        if df.empty:\n            return _empty_meter_data_dataframe()\n        df[\"start\"] = pd.to_datetime(df.start, utc=True)\n        df = df.set_index(\"start\")\n        df[\"value\"] = df[\"value\"].astype(float)\n        if \"estimated\" in df.columns:\n            df[\"estimated\"] = df[\"estimated\"].fillna(False).astype(bool)\n        return df\n    else:\n        raise ValueError(\"orientation not recognized.\")\n</code></pre>"},{"location":"reference/eemeter/utilities/#eemeter.eemeter.utilities.io.temperature_data_from_json","title":"<code>temperature_data_from_json(data, orient='list')</code>","text":"<p>Load temperature data from json to a Series. Farenheit is assumed for building models.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>A list of temperature data, with each row representing a single record.</p> required <code>orient</code> <code>str</code> <p>Format of <code>data</code> parameter. Must be <code>'list'</code>. <code>'list'</code> is a list of lists, with the first element as start date and the second element as temperature.</p> <code>'list'</code> This is an example of the default <code>list</code> structure. <pre><code>[\n    ['2017-01-01T00:00:00+00:00', 3.5],\n    ['2017-01-01T01:00:00+00:00', 5.4],\n    ['2017-01-01T02:00:00+00:00', 7.4],\n]\n</code></pre> <p>Returns:</p> Type Description <code>Series</code> <p>DataFrame with a single column (<code>'tempF'</code>) and a <code>pandas.DatetimeIndex</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>orient</code> is not <code>'list'</code>.</p> Source code in <code>eemeter/eemeter/utilities/io.py</code> <pre><code>def temperature_data_from_json(data: list, orient: str = \"list\") -&gt; pd.Series:\n    \"\"\"Load temperature data from json to a Series. Farenheit is assumed for building models.\n\n    Args:\n        data: A list of temperature data, with each row representing a single record.\n        orient: Format of `data` parameter. Must be `'list'`.\n            `'list'` is a list of lists, with the first element as start date and the second element as temperature.\n\n    Note: This is an example of the default `list` structure.\n        ```python\n        [\n            ['2017-01-01T00:00:00+00:00', 3.5],\n            ['2017-01-01T01:00:00+00:00', 5.4],\n            ['2017-01-01T02:00:00+00:00', 7.4],\n        ]\n        ```\n\n    Returns:\n        DataFrame with a single column (``'tempF'``) and a `pandas.DatetimeIndex`.\n\n    Raises:\n        ValueError: If `orient` is not `'list'`.\n    \"\"\"\n    if orient == \"list\":\n        df = pd.DataFrame(data, columns=[\"dt\", \"tempF\"])\n        series = df.tempF\n        series.index = pd.to_datetime(df.dt, utc=True)\n        return series\n    else:\n        raise ValueError(\"orientation not recognized.\")\n</code></pre>"},{"location":"reference/eemeter/utilities/#eemeter.eemeter.utilities.io.meter_data_to_csv","title":"<code>meter_data_to_csv(meter_data, path_or_buf)</code>","text":"<p>Write meter data from a DataFrame or Series to a CSV. See also <code>pandas.DataFrame.to_csv</code>.</p> <p>Parameters:</p> Name Type Description Default <code>meter_data</code> <code>DataFrame | Series</code> <p>DataFrame or Series with a <code>'value'</code> column and a <code>pandas.DatetimeIndex</code>.</p> required <code>path_or_buf</code> <code>str | FilePath | WriteBuffer[bytes] | WriteBuffer[str]</code> <p>Path or file handle.</p> required Source code in <code>eemeter/eemeter/utilities/io.py</code> <pre><code>def meter_data_to_csv(\n    meter_data: pd.DataFrame | pd.Series,\n    path_or_buf: str | FilePath | WriteBuffer[bytes] | WriteBuffer[str],\n) -&gt; None:\n    \"\"\"Write meter data from a DataFrame or Series to a CSV. See also `pandas.DataFrame.to_csv`.\n\n    Args:\n        meter_data: DataFrame or Series with a ``'value'`` column and a `pandas.DatetimeIndex`.\n        path_or_buf: Path or file handle.\n    \"\"\"\n    if meter_data.index.name is None:\n        meter_data.index.name = \"start\"\n\n    return meter_data.to_csv(path_or_buf, index=True)\n</code></pre>"},{"location":"reference/eemeter/utilities/#eemeter.eemeter.utilities.io.temperature_data_to_csv","title":"<code>temperature_data_to_csv(temperature_data, path_or_buf)</code>","text":"<p>Write temperature data to CSV. See also :any:<code>pandas.DataFrame.to_csv</code>.</p> <p>Parameters:</p> Name Type Description Default <code>temperature_data</code> <code>Series</code> <p>Temperature data series with :any:<code>pandas.DatetimeIndex</code>.</p> required <code>path_or_buf</code> <code>str | FilePath | WriteBuffer[bytes] | WriteBuffer[str]</code> <p>Path or file handle.</p> required Source code in <code>eemeter/eemeter/utilities/io.py</code> <pre><code>def temperature_data_to_csv(\n    temperature_data: pd.Series,\n    path_or_buf: str | FilePath | WriteBuffer[bytes] | WriteBuffer[str],\n) -&gt; None:\n    \"\"\"Write temperature data to CSV. See also :any:`pandas.DataFrame.to_csv`.\n\n    Args:\n        temperature_data: Temperature data series with :any:`pandas.DatetimeIndex`.\n        path_or_buf: Path or file handle.\n    \"\"\"\n    if temperature_data.index.name is None:\n        temperature_data.index.name = \"dt\"\n    if temperature_data.name is None:\n        temperature_data.name = \"temperature\"\n\n    return temperature_data.to_frame().to_csv(path_or_buf, index=True)\n</code></pre>"}]}